---
output: 
  html_document:
    keep_md: false
    toc: true
    toc_float: true
    toc_depth: 5
    number_sections: true
    df_print: kable
    code_folding: hide
params:
  datadir: NULL
  outdir: NULL
  use_labeltransfer: NULL
  refdatapath: NULL
  m_reference: NULL
  sample_metadata: NULL
  comps: NULL
  risc_reference: NULL
  min_num_UMI: 500
  min_num_Feature: 200
  max_perc_mito: 25
  max_perc_hemoglobin: 25
  autofilter_complexity: TRUE
  autofilter_mito: TRUE
  autofilter_nUMI: TRUE
  autofilter_medianabsolutedev_threshold: 3
  autofilter_loess_negative_residual_threshold: -5
  doubletFinder: TRUE
  pcs_indi: 30
  res_indi: 0.5
  pcs_int: 30
  res_int: 0.5
  RISC_louvain_neighbors: 10
  Pseudobulk_mode: NULL
  crossconditionDE_padj_thres: NULL
  crossconditionDE_lfc_thres: NULL
  pathway_padj_thres: 0.1
  species: 'Homo sapiens'
  workernum: 1
  input_seurat_obj: FALSE
  title: 10X analysis - clustering and integration
  author: Alexander Ferrena, Deyou Zheng
  force_redo: FALSE  
title: "`r params$title`"
date: "`r Sys.Date()`"
author: "`r params$author`"
---





```{r setup}

#rmarkdown tips
# https://bookdown.org/yihui/rmarkdown/basics.html


### for code folding, put this under html options above and set echo = T below:
# output: 
#   html_document:
#     code_folding: hide


# make sections with R code
# https://stackoverflow.com/questions/36674824/use-loop-to-generate-section-of-text-in-rmarkdown 

knitr::opts_chunk$set(echo = T, warning=FALSE, message=FALSE, results = 'hold', fig.width = 7, fig.height = 7)

#set whole project directory (use this instead of setwd() in rmd)
# knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
#hopefully commenting just works with cwd

#set do not stop knitting even with errors; obviously dangerous, for testing only
knitr::opts_chunk$set(
  error = F # if true, do not interrupt in case of errors
)


#set timer

timestart = proc.time()


#set memory limit
# this is for parallel via future (for markers)
# some seurat functions also rely on this under the hood...
# pipeline may fail if this is not set


# options(future.globals.maxSize = 850*1024^2) # 850 MB
# options(future.globals.maxSize = 850*1024^2) # 1 GB
#options(future.globals.maxSize = 8000 * 1024^2) # 8 GB

# mostly for Seurat future, increase max mem per core, don't think anything except future uses this
options(future.globals.maxSize = 15000 * 1024^2) # 15 GB



# set seed
set.seed(2022)

```












```{r set_input_output_and_params}


## for testing and / or manually setting things only;
## keep commented otherwise



# bindingIsLocked("params", env = .GlobalEnv)
# unlockBinding("params", env = .GlobalEnv)
# 
# projdir = '/Users/alexanderferrena/Dropbox (EinsteinMed)/mypkgs/scDAPP/tests/covid/data/'
# 
# params <- list(
#   datadir = paste0(projdir, '/datadir/'),
#   outdir = paste0(projdir, 'outs/DEVTEST/' ),
#   Pseudobulk_mode = T,
# 
#   use_labeltransfer = F,
#   # refdatapath = paste0(projdir, 'Reference_Seurat_Generation/Fuwai_E105_Wn1Cre_Hearts/CNCCsE105_Dub_namedClusters.rds'),
#   # m_reference = paste0(projdir, 'Reference_Seurat_Generation/Fuwai_E105_Wn1Cre_Hearts/Markers.rds'),
# 
#   sample_metadata = paste0(projdir, '/sample_metadata.csv'),
#   comps = paste0(projdir, '/comps.csv'),
# 
#   min_num_UMI = 500,
#   min_num_Feature = 200,
#   max_perc_mito = 25,
#   max_perc_hemoglobin = 25,
#   autofilter_complexity = F,
#   autofilter_mito = T,
#   autofilter_nUMI = F,
#   autofilter_medianabsolutedev_threshold = 3,
#   autofilter_loess_negative_residual_threshold = -5,
# 
#   doubletFinder = T,
# 
# 
#   pcs_indi = 30,
#   res_indi = 0.5,
#   pcs_int = 30,
#   res_int = 1,
#   RISC_louvain_neighbors=10,
# 
#   risc_reference = NULL,
#   crossconditionDE_padj_thres = NULL,
#   crossconditionDE_lfc_thres = NULL,
#   pathway_padj_thres = 0.1,
#   species = 'Homo sapiens',
#   workernum = 6,
#   input_seurat_obj = T,
#   force_redo = F
# )











#set verbosity --> deprecated, keep false
verbose=F


## key params, setting paths
datadir <- paste0(params$datadir, '/')

if(is.null(datadir)){stop('Please set datadir, path to cellranger results')}

#input seurat obj
input_seurat_obj <- params$input_seurat_obj
if(is.null(input_seurat_obj)){input_seurat_obj <- F}



# set output dir
outdir <- paste0(params$outdir, '/')
if(is.null(outdir)){stop('Please set outdir, output folder')}

dir.create(outdir, recursive = T)

#set up output dir for individual samples
outdir_indi <- paste0(outdir, '/individualsample_analysis')

dir.create(outdir_indi)

#prep a dir for int results
outdir_int <- paste0(outdir, '/multisample_integration/') 

dir.create(outdir_int)




#set path to reference data for label transfer.


use_labeltransfer <- params$use_labeltransfer
if(is.null(use_labeltransfer)){stop('Please set use_labeltransfer to T/F; if T, please also provide paths refdatapath and m_reference')}

if(use_labeltransfer == T){
  
  refdatapath <- params$refdatapath
  if(is.null(refdatapath)){stop('Please set refdatapath, path to reference scRNAseq Seurat object .rds file with "Celltype" in meta.data')}
  
  
  
  # ref markers
  m_reference <- params$m_reference
  
  ### just added: SeuratLabelTransfer.normalization.method
  
  # SeuratLabelTransfer.normalization.method <- params$SeuratLabelTransfer.normalization.method
  
  if(is.null(m_reference)){stop('Please set m_reference, path to FindAllMarkers result from reference celltypes, saved as .rds file')}
  
} else{
  refdatapath <- NA
  m_reference <- NA
  # SeuratLabelTransfer.normalization.method <- NA
}




#de test use
Pseudobulk_mode <- params$Pseudobulk_mode
if(is.null(Pseudobulk_mode)){stop('Please set "Pseudobulk_mode" as either TRUE or FALSE')}


## analysis parameters: dimreduction and clustering hyperparameters

# just use defaults in params since its easier, except for pwaycats

pwaycats <- c("HALLMARK", "GO_BP", "GO_MF", "GO_CC", "CP_REACTOME", "CP_KEGG")


#get risc reference
risc_reference <- params$risc_reference


#autofilter parameters
min_num_UMI = params$min_num_UMI
min_num_Feature = params$min_num_Feature
max_perc_mito = params$max_perc_mito
max_perc_hemoglobin = params$max_perc_hemoglobin
autofilter_complexity = params$autofilter_complexity
autofilter_mito = params$autofilter_mito
autofilter_nUMI = params$autofilter_nUMI

autofilter_medianabsolutedev_threshold = params$autofilter_medianabsolutedev_threshold
autofilter_loess_negative_residual_threshold = params$autofilter_loess_negative_residual_threshold

doubletFinder = params$doubletFinder

# #check package versions and add warnings
# if( (packageVersion('DoubletFinder') == "2.0.3") & (packageVersion('Seurat') >= "5.0.0") ){
#   warning('DoubletFinder v2.0.3 (latest update as of Nov 14 2023) is not compatible with Seurat > v5.0.0.\nTurning off DoubletFinder.\nTo use DoubletFinder, try downgrading to Seurat v4:', 
#           '\n',
#           "https://satijalab.org/seurat/articles/install_v5#install-previous-versions-of-seurat"
#           
#           )
#   
#   doubletFinder <- F
# }


if( (packageVersion('DoubletFinder') == "2.0.3") & (packageVersion('Seurat') >= "5.0.0") ){
  
  warning('Will attempt to coerce Seurat v5 object to work with DoubletFinder v2.0.3; this is unstable and does not always work! If any errors arise, set doubletFinder to FALSE in pipeline runner')
  
}



pcs_indi <- params$pcs_indi
res_indi <- params$res_indi
pcs_int <- params$pcs_int
res_int <- params$res_int
RISC_louvain_neighbors <- params$RISC_louvain_neighbors


#for these, defaults will be null, then set to lenient if pseudobulk and strict if wilcox

crossconditionDE_padj_thres <- params$crossconditionDE_padj_thres
crossconditionDE_lfc_thres <- params$crossconditionDE_lfc_thres


if(Pseudobulk_mode == T){
  
  if(is.null(crossconditionDE_padj_thres)){
    crossconditionDE_padj_thres <- 0.1
  }
  
  if(is.null(crossconditionDE_lfc_thres)){
    crossconditionDE_lfc_thres <- 0
  }
  
  
}

if(Pseudobulk_mode == F){
  
  if(is.null(crossconditionDE_padj_thres)){
    crossconditionDE_padj_thres <- 0.05
  }
  
  if(is.null(crossconditionDE_lfc_thres)){
    crossconditionDE_lfc_thres <- 0.25
  }
  
  
}


pathway_padj_thres <- params$pathway_padj_thres


# pwaycats: NULL
species <- params$species



## parallelization

workernum <- params$workernum

#redo / overwrite
# force_redo <- params$force_redo
force_redo = T


# ## save the parameter choices
# paramsave <- lapply(1:length(params), function(i){
#   var <- names(params)[i]
#   
#   get(var)
# })
# 
# names(paramsave) <- names(params)
# 
# 
# paramsave <- t(data.frame(paramsave))
# 
# paramsave <- cbind(rownames(paramsave), paramsave)
# rownames(paramsave) <- NULL




## defining DE comparisons and sample conditions with metadata

#do this below saving params, since we overwrite these names

#metadata
sample_metadata <- params$sample_metadata
if(is.null(sample_metadata)){stop('Please set sample_metadata, path to csv file with Sample column and Condition column')}

#parse pseudobulk
# read.csv...
sample_metadata <- read.csv(sample_metadata)

#parse factor
sample_metadata$Condition <- factor(sample_metadata$Condition,
                                    levels = unique(sample_metadata$Condition))

#add codes, optional

if(!('Code' %in% colnames(sample_metadata))){
  sample_metadata$Code <- paste0(sample_metadata$Condition, '_', sample_metadata$Sample)
}




#comparisons
comps <- params$comps

if(!is.null(comps)){ comps <- read.csv(comps) }
if(is.null(comps)){
  
  
  if( length(levels(sample_metadata$Condition)) > 2 ){
    
    warning('"comps" data.frame not provided, will try to guess from sample_metadata')
    comps <- data.frame(c1 = levels(sample_metadata$Condition)[1],
                        c2 = levels(sample_metadata$Condition)[2])
    
  } else{
    
    stop('Please set comps, path to csv file c1 and c2 column defining comparisons of conditions to use')
    
  }
  
  
}






#save params as a data.frame
pl <- list(datadir = datadir,
           outdir = outdir,
           sample_metadata = params$sample_metadata,
           comps = params$comps,
           
           use_labeltransfer = use_labeltransfer,
           refdatapath = refdatapath,
           m_reference = m_reference,
           # SeuratLabelTransfer.normalization.method=SeuratLabelTransfer.normalization.method,
           
           min_num_UMI = min_num_UMI,
           min_num_Feature = min_num_Feature,
           max_perc_mito = max_perc_mito,
           max_perc_hemoglobin = max_perc_hemoglobin,
           autofilter_mito = autofilter_mito,
           autofilter_nUMI = autofilter_nUMI,
           autofilter_complexity = autofilter_complexity,
           autofilter_medianabsolutedev_threshold = autofilter_medianabsolutedev_threshold,
           autofilter_loess_negative_residual_threshold = autofilter_loess_negative_residual_threshold,
           doubletFinder = doubletFinder,
           
           risc_reference = ifelse(is.null(risc_reference), 'auto', risc_reference) ,
           
           pcs_indi = pcs_indi,
           res_indi = res_indi,
           pcs_int = pcs_int,
           res_int = res_int,
           RISC_louvain_neighbors = RISC_louvain_neighbors,
           
           Pseudobulk_mode = Pseudobulk_mode,
           crossconditionDE_padj_thres = crossconditionDE_padj_thres,
           crossconditionDE_lfc_thres = crossconditionDE_lfc_thres,
           pathway_padj_thres = pathway_padj_thres,
           species = species,
           
           workernum = workernum,
           input_seurat_obj = input_seurat_obj
)

pldf <- data.frame(parameter = names(pl),
                   value = unlist(pl))

#write it out
write.csv(pldf, paste0(outdir, '/pipeline_parameters.csv'), quote = F, row.names = F)


```




# Introduction



This report summarizes analysis of single-cell RNA-sequencing (scRNA-seq) data including single sample analysis, label transfer from a cell-type annotated reference (optional), integration with batch correction, differential expression with support for pseudobulk and multi-condition comparisons, and pathway analysis. All plots, tables, markers, Seurat objects, RISC object, DE results, and pathway analysis results are stored in the output folder.

The analysis pipelines in this report were developed by the lab of Dr. Deyou Zheng in the Department of Genetics and Department of Neuroscience at Albert Einstein College of Medicine. The pipeline was assembled primarily by PhD candidate Alexander Ferrena with additional input from all lab members.

## Description of methods

Below is a short methods-section style description of the pipeline. More detailed information on can be found in each sub-section. If required, software versions of all R packages can be found at the bottom of the document in the SessionInfo section. The version of Cellranger can be found in the web_summary.html files provided with the data release. Please read carefully and adjust accordingly before using for manuscripts or applications.

```{r methods_intro, results='asis'}
text1 <- 
  '
Sequencing data from the 10x Chromium samples were first analyzed with Cellranger to generate cell level gene expression data [(10X Genomics)](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger). Cells with fewer than 500 Unique Molecular Identifiers (UMIs) detected, fewer than 200 unique genes detected, more than 25% mitochondrial content, or more than 25% hemoglobin gene expression were filtered out (unless otherwise specified). An automated filtering approach to detect outliers of these variables based on median absolute deviation above 3 was also applied. Furthermore, complexity analysis based on the expected number of genes given number of UMIs per cell was also used to filter out poor quality cells. Samples were analyzed using the Seurat workflow [(Hao et al 2021)](https://doi.org/10.1016/j.cell.2021.04.048). Each sample was normalized using the SingleCellTransform pipeline [(Hafemeister & Satija 2019)](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1) with method set to "glmGamPoi" [(Ahlmann-Eltze & Huber 2020)](https://academic.oup.com/bioinformatics/article/36/24/5701/6028985). 30 principal components were used for graph construction and resolution was set to 0.5 for Louvain clustering (unless otherwise specified). Marker analysis was performed using the Wilcoxon Rank Sum Test as implemented in the Seurat FindAllMarkers() function with "only.pos" set to True. To identify cell types present in each sample, the Seurat anchor-based Label Transfer method was used, based on a single-cell RNA-seq dataset from similar tissue (unless otherwise specified).


'


if(Pseudobulk_mode == T){
  
  text2 <- 'Samples were integrated using the RISC package [(Liu, Zheng et al Nat Biotech 2021)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8456427/). 30 PCs were used for integration as well as for post-clustering analysis including Louvain clustering, unless otherwise specified. Compositional analysis to compare proprotional abundance of clusters between conditions was performed via the Propeller test as implemented in the speckle package [(Phipson et al 2022)](https://academic.oup.com/bioinformatics/article/38/20/4720/6675456). Differential expression analysis across conditions followed a pseudobulking approach based on the EdgeR-Likelihood Ratio Test (LRT) method for each cluster [(Robinson et al 2010)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2796818/). Pathway analysis on the differentially expressed genes was performed using Gene Set Enrichment Analysis (GSEA) as implemented in the FGSEA package [(Subramanian et al 2005)](https://www.pnas.org/doi/10.1073/pnas.0506580102), [(Korotkevich et al 2021)](https://www.biorxiv.org/content/10.1101/060012v3). Pathways were downloaded from the Molecular Signatures Database using the R package msigdbr [(Liberzon et al 2015)](https://academic.oup.com/bioinformatics/article/27/12/1739/257711), [(Dolgalev 2022)](https://github.com/igordot/msigdbr).
'
  
}
if(Pseudobulk_mode == F){
  
  text2 <- 'Samples were integrated using the RISC package [(Liu, Zheng et al Nat Biotech 2021)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8456427/). 30 PCs were used for integration as well as for post-clustering analysis including Louvain clustering, unless otherwise specified. Compositional analysis to compare proprotional abundance of clusters between conditions was performed via the 2-sample Z test as implemented in the R prop.test() function. Differential expression analysis across conditions used the Wilcoxon test as implemented in the Seurat FindMarkers() function. Pathway analysis on the differentially expressed genes was performed using Gene Set Enrichment Analysis (GSEA) as implemented in the FGSEA package [(Subramanian et al 2005)](https://www.pnas.org/doi/10.1073/pnas.0506580102), [(Korotkevich et al 2021)](https://www.biorxiv.org/content/10.1101/060012v3). Pathways were downloaded from the Molecular Signatures Database using the R package msigdbr [(Liberzon et al 2015)](https://academic.oup.com/bioinformatics/article/27/12/1739/257711), [(Dolgalev 2022)](https://github.com/igordot/msigdbr).
'
  
}


# cat(text1); cat(text2)

alltext <- paste0(text1, '\n', text2)
cat(alltext)
```






## Pipeline Parameters





```{r printparams_and_samples, results='asis'}


plotlab <- '

### Sample names and conditions

Here we list the sample names, conditions, and code names for each sample.


'

cat(plotlab)

knitr::kable(sample_metadata)




plotlab <- '

### Comparisons to perform

We set up a cross-condition comparison using each row of the table below. For example, for each row, the "c1" column is compared with the "c2" column in differential expression analysis.



'

cat(plotlab)

knitr::kable(comps)



plotlab <- '

### Analysis parameters

Here we list the key analysis parameters used in this analysis.



'

cat(plotlab)

rownames(pldf) <- NULL
knitr::kable(pldf)


```





# Individual sample processing and analysis

First, we preprocess and analyze each individual sample. This will go through the following steps for each sample:

* Preprocessing: Normalize and pre-process with the Seurat SingleCellTransform (SCT) pipeline
* Dimension reduction and clustering: Principal component analysis, graph construction, clustering, and visualization via UMAP to discover clusters in each sample
* Marker analysis: using the Wilcoxon test for differential expression, find unique marker genes of each cluster
* Label transfer: from a reference single-cell dataset, quantify how much each cell in the  data resembles a known cell type


After the analysis of individual samples, we will do an integrated analysis.



```{r load_libs_and_functions }

### load packages, set seed

library(tidyverse)
library(patchwork)  # combine plots
library(RISC)
library(Seurat)
library(scDAPP)
library(DoubletFinder)

library(future)
library(parallel)
library(foreach)

library(glmGamPoi)  # for faster SCT
library(ComplexHeatmap) # for heatmaps
library(ggdendro)       #for clustering dendrograms

library(ggridges) # qc ridgeplots

library(edgeR)

library(msigdbr)          #get pathways (cross species) from msigdb

library(hdf5r) # HARD TO INSTALL: installed thru mamba
library(ggalluvial) # part of alluvial plot
library(ggfittext) # part of alluvial plot
library(ggrepel) # part of alluvial plot


set.seed(2022)





```






# Data Quality Assessment



Once sequencing is completed, we get a file that has the barcode and cDNA sequences as reads (a bunch of ATGCs), along with some sequencing quality information. This file is called a “FASTQ” and has the file extension “.fastq”. The downstream analysis relies on analyzing counts of transcripts for each cell. This means we have to do a few things:

* Alignment: assign each sequence read to the gene it came from.

* Gene demultiplexing: Once the read-pair is aligned to a gene, we count the UMI barcode as a count for that gene. Two reads may come from the same gene, but if they have the same UMI, it means they came from the same transcript, so it only counts at one UMI. This allows us to get around the problem of short-read sequencing inherent to Illumina technology, to count actual transcripts rather than counting reads.

* cell demultiplexing: During 10X library prep, each cell is isolated and given a barcode. Every read from that cell is labelled with the cell barcode. Using the barcode, we assign the read to a specific cell.


These preprocessing steps are performed by the 10x Genomics software called Cellranger. Cellranger produces some outputs including web_summary.html files that allow basic exploration of the sample quality. It is good practice to review these files for each sample.



Downstream analysis, includng clustering and label transfer, works with the output of Cellranger Count. This includes a gene by cell matrix. Each row is a gene, each column is a cell and each value is the number of UMIs for each gene from each cell; typically, this is ~20K genes (rows) x ~8K cells (columns). Once that is all complete, we are ready for the analysis performed in this document. We use the Seurat pipeline in R to analyze this data, which involves the steps detailed in section 1.

Flawed datapoints can include poor quality cells and multiplets. Poor quality cells can include cells which have sustained membrane damage and leakage of their RNA, a process which typically results the observed transcriptomic profile of that cell displaying a high proportion of mitochondrial RNA, or low numbers of UMIs or unique genes. Multiplets can be caused by random error of poisson loading of single-cells in the 10X microfluidics chamber. These can influence and bias downstream analysis. Occasionally, we also sometimes observe red blood cells despite usage of RBC lysis buffer. These should not be in the data and so we remove them as well.




```{r read_in_data}




#set up output dir for individual samples
outdir_indi <- paste0(outdir, '/individualsample_analysis')

dir.create(outdir_indi)

### read in data ###



### use pseudobulk_md for good sample order
samples <- sample_metadata$Sample
names(samples) <- sample_metadata$Code



#read in data from filtered_feature_bc_matrix.h5 files or from Seurat object (ie for hashed)

if(input_seurat_obj == T){## read in
  sobjlist <- lapply(samples, function(samp){
    message('\nReading in ', samp)
    
    
    #for HTO, we will assume saved objects
    sobjfile <- paste0(datadir, '/', samp, '.rds')
    sobj <- readRDS(sobjfile)
    
    
    
    
    #make project name the Conditon_Sample
    md_samp <- sample_metadata[sample_metadata$Sample==samp,,drop=F]
    
    #make project name the sample
    sobj@project.name <- md_samp$Code
    
    #make orig.ident the code
    sobj$orig.ident <- md_samp$Code
    
    #return seurat obj
    sobj
    
    
  })
} else{
  
  ## read in
  sobjlist <- lapply(samples, function(samp){
    message('\nReading in ', samp)
    
    datafp <- paste0(datadir, '/', samp)
    # if on hpc, use below
    # datafp <- paste0(datadir, '/', samp, '/outs/')
    
    # for the dl data, we need to find the filepath
    h5_filename <- grep(pattern = 'filtered_feature_bc_matrix.h5',
                        list.files(datafp, recursive = T, full.names = T),
                        value = T)
    
    
    
    
    
    #read in
    sobj <- CreateSeuratObject(   Read10X_h5(h5_filename), 
                                  min.cells= 3)
    
    
    
    
    #make project name the Conditon_Sample
    md_samp <- sample_metadata[sample_metadata$Sample==samp,,drop=F]
    
    #make project name the sample
    sobj@project.name <- md_samp$Code
    
    #make orig.ident the code
    sobj$orig.ident <- md_samp$Code
    
    #return seurat obj
    sobj
    
    
  })
  
}


```








```{r filtering_main, message='hold', results='hide', message=F, fig.keep='all'}



#add in qc values for mito and hemoglobin

sobjlist <- lapply(sobjlist, function(sobj){
  #mito content, add to metadata
  mito.features <- grep(pattern = "^mt-", x = rownames(x = sobj), value = TRUE, ignore.case = T)
  sobj[["percent.mito"]] <- Seurat::PercentageFeatureSet(sobj, features = mito.features)
  
  #hemoglobin content, add to metadata
  sobj$percent.hemoglobin <- scDAPP::calculate_percent.hemoglobin(sobj)
  
  #calculate phase (if possible, sometimes it fails)
  try(
    sobj <- CellCycleScoring(sobj,
                             s.features = Seurat::cc.genes.updated.2019$s.genes,
                             g2m.features = Seurat::cc.genes.updated.2019$g2m.genes)
  )
  
  sobj
  
})



#here we do most of the filtering 

rawobjsdir <- paste0(outdir_indi, '/unfiltered_Seurat_objects')
dir.create(rawobjsdir, recursive = T)

outdir_indi_seuratobjs <- paste0(outdir_indi, '/processed_Seurat_objects')
dir.create(outdir_indi_seuratobjs, recursive = T)

qcdir <- paste0(outdir_indi, '/qualitycontrol_filtering')
dir.create(qcdir, recursive = T)


#make a temp dir and run one at a time or parallel with foreach...
## remove seurat objects; save to tmp files instead...
qctmpdir <- paste0(qcdir, '/qctmpdir/')
dir.create(qctmpdir, recursive = T)
sobjlist <- lapply(sobjlist, function(sobj){
  code <- sobj@project.name
  tmpsobjfp <- paste0(qctmpdir, '/', code, '.rds')
  saveRDS(sobj, tmpsobjfp)
  return(sobj)
})


#clean up env

rm(sobjlist)

invisible(gc(full = T, reset = F, verbose = F))

#actual processing steps

#0. read in each sample from temp
#1. normalize and cluster raw data w/o filter
#2. apply autofilter
#3. filter out initial auto filter
#4. IF DF == T: renormalize, recluster, apply doubletfinder, refilter
#5. renormalize, recluster with real clustering parameters
#6. add all filter out annotation to raw sobj
#7. do some analysis on raw and save it
#8. save files (raw and filtered/processed)
#9. return autofilter results

cl <- parallel::makeCluster(workernum)
doParallel::registerDoParallel(cl)


codes <- sample_metadata$Code
# codes <- codes[11:17] troubleshoot particular samples



# af_md_list <- lapply(codes, function(code){
af_md_list <- foreach(code = sample_metadata$Code,
                      .packages = c('Seurat', 'ggplot2', 'dplyr',
                                    'scDAPP','grid', 'irlba', 'Matrix'), .verbose = T) %dopar%
  {
    
    
    message(code)
    
    #read in sobj 
    sobj <- readRDS(paste0(qctmpdir, '/', code, '.rds'))
    
    
    #1. normalize and cluster raw data w/o filter
    
    #normalize and cluster
    suppressWarnings(sobj <- Seurat::SCTransform(sobj, verbose = T, method="glmGamPoi"))
    
    sobj <- Seurat::RunPCA(object = sobj, verbose = F)
    
    sobj <- Seurat::FindNeighbors(object = sobj, dims = 1:30, verbose = F)
    sobj <- Seurat::FindClusters(object = sobj, resolution = 0.1, verbose = F, algorithm = 1)
    
    sobj <- Seurat::RunUMAP(sobj, dims = 1:30)
    
    
    
    
    #2. apply autofilter 
    af <- scDAPP::autofilter(sobj, 
                             min_num_UMI = min_num_UMI,
                             min_num_Feature = min_num_Feature,
                             max_perc_mito = max_perc_mito,
                             max_perc_hemoglobin = max_perc_hemoglobin,
                             globalfilter.complexity = autofilter_complexity,
                             globalfilter.mito = autofilter_mito,
                             globalfilter.libsize = autofilter_nUMI,
                             mad.score.threshold = autofilter_medianabsolutedev_threshold,
                             loess_negative_residual_threshold = autofilter_loess_negative_residual_threshold
    )
    
    
    
    
    
    #3. filter out initial auto filter 
    
    #name unfiltered object as sobjraw, and filtered as sobj for now and sobjsave after
    
    sobjraw <- sobj
    
    
    cellstatus <- af$cellstatus
    
    goodcells <- cellstatus[cellstatus$filteredout==F,"barcodes"]
    
    sobj <- sobj[,goodcells]
    
    
    
    
    #4. IF DF == T: renormalize, recluster, apply doubletfinder, refilter
    
    if(doubletFinder == T){
      #filter, re-proc
      
      
      ### temporary fix for doubletfinder v2.0.3 and Seurat v5: coerce seurat to "v3" instead of v5 object
      if( (packageVersion('DoubletFinder') == "2.0.3") & (packageVersion('Seurat') >= "5.0.0") ){
        
        ## try to make it a old seurat object...
        sobj_df <- GetAssayData(sobj, assay = 'SCT', layer = 'data')
        sobj_df <- CreateAssayObject(sobj_df)
        sobj_df <- CreateSeuratObject(sobj_df)
        
        warning('Will attempt to coerce v5 Seurat object to work with DoubletFinder v2.0.3; this is unstable and does not always work! If any errors arise, set doubletFinder to FALSE in pipeline runner')
        
      } else{sobj_df <- sobj}
      
      
      #normalize and cluster
      suppressWarnings(sobj_df <- Seurat::SCTransform(sobj_df, verbose = T, method="glmGamPoi"))
      
      sobj_df <- Seurat::RunPCA(object = sobj_df, verbose = F)
      
      sobj_df <- Seurat::FindNeighbors(object = sobj_df, dims = 1:30, verbose = F)
      sobj_df <- Seurat::FindClusters(object = sobj_df, resolution = 0.1, verbose = F, algorithm = 1)
      
      sobj_df <- RunUMAP(sobj_df, dims = 1:30)
      
      
      try(expr = {
        ### run DF
        af <- scDAPP::doubletfinderwrapper(sobj_df, 
                                           autofilterres = af, 
                                           num.cores = 1)
        
        
        
        
        #filter, re-proc
        cellstatus <- af$cellstatus
        
        goodcells <- cellstatus[cellstatus$filteredout==F,"barcodes"]
        
        sobj <- sobj[,goodcells]
      })
      
      rm(sobj_df); gc(full = T)
      
      
      
      
    }
    
    
    
    
    
    
    #previously we did main analysis here, for ease of code reading
    # we'll do it later in the clustering section
    
    # MAKE SURE RAW PREFILT CLUSTERS ARE LABELLED APPROPRIATELY IN SOBJSAVE 
    
    colnames(sobj@meta.data)[grepl('SCT_snn_res.0.1', colnames(sobj@meta.data))] <- 'PREFILTER_SCT_snn_res.0.1'
    
    #name filtered object as sobjsave
    sobjsave <- sobj ; rm(sobj)
    
    
    
    #7. do some analysis on raw and save it
    
    #do a bit of analysis
    #add af cell status to sobjraw md
    sobjraw@meta.data <- cbind(sobjraw@meta.data, af$cellstatus[,-1])
    
    #find markers; do not futurize, it breaks everything
    
    m <- FindAllMarkers(sobjraw, only.pos = T)
    # as of Nov 9 2023 (Seurat v5): add score to markers
    m$score <- (m$pct.1 - m$pct.2) * m$avg_log2FC
    
    
    #prep genes
    n <- 5
    top <- m %>% group_by(cluster) %>% top_n(n = n, wt = score)
    
    #make some plots
    d_rawclust <- DimPlot(sobjraw, group.by = 'seurat_clusters', label = T, repel = T)+ggtitle('Unfiltered data clusters', subtitle = 'Louvain res = 0.1')
    
    d_raw_filt <- DimPlot(sobjraw, group.by = 'filteredout', label = F, repel = T)
    
    
    sobjraw$filterreason <- factor(sobjraw$filterreason, levels = names(sort(table(sobjraw$filterreason), decreasing = T)))
    d_raw_filt_reason <- DimPlot(sobjraw, group.by = 'filterreason', label = F, repel = T)
    
    fp_raw_qc <- FeaturePlot(sobjraw, c('nCount_RNA', 'nFeature_RNA', 
                                        'percent.mito', 'percent.hemoglobin'),
                             order = T)
    
    #prep per-cluster filter numbers
    tab_filt_by_clust <- table(sobjraw$filterreason, sobjraw$seurat_clusters)
    tab_filt_by_clust <- t(tab_filt_by_clust)
    rownames(tab_filt_by_clust) <- paste0('cluster_', rownames(tab_filt_by_clust))
    colnames(tab_filt_by_clust) <- gsub(x = colnames(tab_filt_by_clust),
                                        pattern = '\\.', '\n')
    
    
    
    hm_raw <- DoHeatmap(sobjraw, top$gene, raster = F)+NoLegend() + labs(title = "Pre-filter cluster markers")
    
    # d_filt_clust <- DimPlot(sobjraw, group.by = newclustname, label = T, repel = T)+ggtitle('Filtered data clusters')
    
    
    #alluvial plot: prep colors and make sure order is hi to lo
    sobjraw$filterreason <- factor(sobjraw$filterreason, levels = names(sort(table(sobjraw$filterreason), decreasing = T)))
    pal <- grDevices::colorRampPalette(RColorBrewer::brewer.pal('Dark2', n = 8))(length(levels(sobjraw$seurat_clusters))) 
    
    
    ap_filt <- alluvialplot(sobjraw@meta.data[,c('seurat_clusters', 'filteredout')])+
      scale_fill_manual(values = pal)+
      labs(title = 'Cluster filtering')
    
    ap_filt_reason <- alluvialplot(sobjraw@meta.data[,c('seurat_clusters', 'filterreason')])+
      scale_fill_manual(values = pal)+
      labs(title = 'Cluster filtering reason')
    
    
    #add some basic filter vln plots
    comm <- af$allcommands
    rownames(comm) <- comm$Command
    
    af$vln_umi <- VlnPlot(sobjraw, 'nCount_RNA', group.by = 'orig.ident')+
      scale_y_log10(labels = scales::label_comma())+
      geom_hline(yintercept = comm['min_num_UMI', 2], 
                 linetype = 'dotted')+
      labs(caption = paste0("cutoff = ", comm['min_num_UMI', 2]))
    
    af$vln_feature <- VlnPlot(sobjraw, 'nFeature_RNA', group.by = 'orig.ident')+
      scale_y_log10(labels = scales::label_comma())+
      geom_hline(yintercept = comm['min_num_Feature', 2], 
                 linetype = 'dotted')+
      labs(caption = paste0("cutoff = ", comm['min_num_Feature', 2]))
    
    
    af$vln_mito <- VlnPlot(sobjraw, 'percent.mito', group.by = 'orig.ident')+
      geom_hline(yintercept = comm['max_perc_mito', 2], 
                 linetype = 'dotted')+
      labs(caption = paste0("cutoff = ", comm['max_perc_mito', 2]))
    
    af$vln_hemo  <- VlnPlot(sobjraw, 'percent.hemoglobin', group.by = 'orig.ident')+
      geom_hline(yintercept = comm['max_perc_hemoglobin', 2], 
                 linetype = 'dotted')+
      labs(caption = paste0("cutoff = ", comm['max_perc_hemoglobin', 2]))
    
    
    #add to autofilter
    af$d_rawclust <- d_rawclust
    af$d_raw_filt <- d_raw_filt
    af$d_raw_filt_reason <- d_raw_filt_reason
    
    af$fp_raw_qc <- fp_raw_qc
    
    af$tab_filt_by_clust <- tab_filt_by_clust
    
    af$hm_raw <- hm_raw
    #af$d_filt_clust <- d_filt_clust
    
    
    af$ap_filt <- ap_filt
    af$ap_filt_reason <- ap_filt_reason
    
    
    #change colnames for baseline sumary
    colnames(af$baseline_qc_summary) <- gsub("summary_", "summary\n", colnames(af$baseline_qc_summary))
    
    
    
    #save it all
    
    
    # save the raw objects
    saveRDS(sobjraw, paste0(rawobjsdir, '/Unfiltered-SeuratObject-', code, '.rds'))
    
    #save the autofilter as a nice pdf
    afpdf <- paste0(qcdir, '/QC_autofilter_summary-', code,'.pdf')
    
    pdf(afpdf, height = 10, width = 10)
    
    
    
    pdftable(af$filtersummary, title = 'Cell Filtering Summary')
    
    pdftable(af$allcommands, title = 'Filter parameters')
    
    pdftable(round(af$baseline_qc_summary, 2), title = 'QC summary stats')
    
    
    
    
    print(af$vln_umi)
    print(af$vln_feature)
    print(af$vln_mito)
    print(af$vln_hemo)
    
    print(af$globalfilter.complexity)
    print(af$globalfilter.libsize)
    print(af$globalfilter.mito)
    
    
    print(af$d_rawclust)
    print(af$d_raw_filt)
    print(af$d_raw_filt_reason)
    print(af$fp_raw_qc)
    
    
    pdftable(af$tab_filt_by_clust, title = 'Cell filtering per cluster')
    
    print(af$hm_raw)
    
    # print(af$d_filt_clust)
    
    print(af$ap_filt)
    print(af$ap_filt_reason)
    
    
    
    
    dev.off()
    
    
    #8. save procesed object
    #code <- sobj@project.name
    sobjfile <- paste0(qctmpdir, '/', code, '.rds')
    
    saveRDS(sobjsave, sobjfile)
    
    
    #9. return autofilter and raw md
    rawmd <- sobjraw@meta.data
    rm(sobjsave, sobjraw)
    invisible(gc(full = T, reset = F, verbose = F))
    
    
    list(af, rawmd)
    
    
  } # for foreach
# }) # for lapply



parallel::stopCluster(cl)


#recover the autofilter and metadata lists
aflist <- lapply(af_md_list, function(subl){
  subl[[1]]
})

mdlist <-  lapply(af_md_list, function(subl){
  subl[[2]]
})

names(aflist) <- sample_metadata$Code
names(mdlist) <- sample_metadata$Code

#clean mem
rm(af_md_list)
invisible(gc(full = T, reset = F, verbose = F))




```





```{r filtering_plotprep, message='hold', results='hide', message=F, fig.keep='all'}

### prepare some summary plots for filtering


# #from autofilter list, get baseline summaries and cell filter stats
cn <- colnames(aflist[[1]]$baseline_qc_summary)

bsl <- lapply(cn, function(var){
  
  sampsum <- lapply(1:length(aflist), function(i){
    
    af <- aflist[[i]]
    samp <- names(aflist)[i]
    sampsum <- af$baseline_qc_summary[,var,drop = F]
    colnames(sampsum) <- samp
    
    sampsum
    
    
  })
  
  sampsum <- dplyr::bind_cols(sampsum)
  sampsum <- t(sampsum)
  
})

cn <- gsub(x=cn, 'summary\n', '')
names(bsl) <- cn



#from outlier list, filter summary
fs <- lapply(1:length(aflist), function(i){
  af <- aflist[[i]]
  samp = names(aflist)[i]
  sum <- af$filtersummary
  rownames(sum) <- sum[,1]
  sum <- sum[,2, drop = F]
  colnames(sum) <- samp
  sum
})

#sometimes, some samples don't have any removed for some category ,so need to fix
remnames <- unique(unlist(lapply(fs, rownames)))

fs <- lapply(fs, function(sum){
  
  #identify missing filters and set to 0
  if( any(!(remnames %in% rownames(sum))) ){
    missingfilts <- remnames[!(remnames %in% rownames(sum))]
    adddf <- data.frame(samp = rep(0, length(missingfilts)))
    colnames(adddf) <- colnames(sum)
    rownames(adddf) <- missingfilts
    sum <- rbind(sum, adddf)
  }
  
  
  #make sure all have same order
  sum <- sum[match(remnames, rownames(sum)),,drop=F]
  
})


#bind table
fs <- dplyr::bind_cols(fs)
fs <- t(fs)

#shorten names
colnames(fs) <- gsub('globalfilter', 'auto', colnames(fs))
colnames(fs) <- gsub('DoubletFinder_doublet', 'Doublet', colnames(fs))

#rearragne, total cells, unfilt, then filtered cells
fs <- cbind( fs[,c(ncol(fs), ncol(fs)-1)], fs[,1:(ncol(fs)-2)] )


## also prep some summary plots for each sample ##

### pre-filt plots

combmd <- dplyr::bind_rows(mdlist)


umilims <- c(min(combmd$nCount_RNA), max(combmd$nCount_RNA)) 
featlims <- c(min(combmd$nFeature_RNA), max(combmd$nFeature_RNA))

### ridgeplots / ridgeline density plots


# #density plot for nCount_RNA
var <- "nCount_RNA"
submd <- combmd[,c(var,'orig.ident')]
colnames(submd)[1] <- 'var'
submd$var <- log10(submd$var)
maxdens <- aggregate(var ~ orig.ident, submd, function(x){max(density(x)$y)})

# submd <- combmd[,c(var,'orig.ident')]
# colnames(submd)[1] <- 'var'
# repelcoords <- aggregate(var ~ orig.ident, submd, median)
# repelcoords$maxdens <- maxdens$var
# 
# dens_UMI <- ggplot(combmd, aes(x = .data[[var]], col = orig.ident))+
#   geom_density()+
#   ggrepel::geom_text_repel(inherit.aes = F,
#                            data = repelcoords,
#                            aes(x = var, y = maxdens, label = orig.ident, color = orig.ident))+
#   scale_x_log10(labels = scales::label_comma(), name = var)

dens_UMI <- ggplot(combmd, aes(x = .data[[var]], y=orig.ident, fill=after_stat(log10(x))))+
  geom_density_ridges_gradient(scale=0.9, stat = "binline", bins = 50) +
  scale_x_log10(labels = scales::label_comma(), name = var, limits = umilims)+
  scale_y_discrete(limits = rev(sample_metadata$Code))+
  viridis::scale_fill_viridis( option = "C", alpha = 0.7) +
  theme_ridges()+theme(legend.position = 'none')

# 
# 
# #density plot for nFeature_RNA
var <- "nFeature_RNA"
submd <- combmd[,c(var,'orig.ident')]
colnames(submd)[1] <- 'var'
submd$var <- log10(submd$var)
maxdens <- aggregate(var ~ orig.ident, submd, function(x){max(density(x)$y)})

# submd <- combmd[,c(var,'orig.ident')]
# colnames(submd)[1] <- 'var'
# repelcoords <- aggregate(var ~ orig.ident, submd, median)
# repelcoords$maxdens <- maxdens$var
# 
# dens_feature <- ggplot(combmd, aes(x = .data[[var]], col = orig.ident))+
#   geom_density()+
#   ggrepel::geom_text_repel(inherit.aes = F,
#                            data = repelcoords,
#                            aes(x = var, y = maxdens, label = orig.ident, color = orig.ident))+
#   scale_x_log10(labels = scales::label_comma(), name = var)


dens_feature <- ggplot(combmd, aes(x = .data[[var]], y=orig.ident, fill=after_stat(log10(x))))+
  geom_density_ridges_gradient(scale=0.9, stat = "binline", bins = 50) +
  scale_x_log10(labels = scales::label_comma(), name = var, limits = featlims)+
  scale_y_discrete(limits = rev(sample_metadata$Code))+
  viridis::scale_fill_viridis( option = "C", alpha = 0.7) +
  theme_ridges()+theme(legend.position = 'none')
# 
# 
# #density plot for mito
var <- "percent.mito"
submd <- combmd[,c(var,'orig.ident')]
colnames(submd)[1] <- 'var'
maxdens <- aggregate(var ~ orig.ident, submd, function(x){max(density(x)$y)})

# submd <- combmd[,c(var,'orig.ident')]
# colnames(submd)[1] <- 'var'
# repelcoords <- aggregate(var ~ orig.ident, submd, median)
# repelcoords$maxdens <- maxdens$var
# 
# dens_mito <- ggplot(combmd, aes(x = .data[[var]]+0.1, col = orig.ident))+
#   geom_density()+
#   ggrepel::geom_text_repel(inherit.aes = F,
#                            data = repelcoords,
#                            aes(x = var, y = maxdens, label = orig.ident, color = orig.ident))+
#   scale_y_continuous(name = 'density')


dens_mito <- ggplot(combmd, aes(x = .data[[var]]+1, y=orig.ident, fill=after_stat(log10(x))))+
  geom_density_ridges_gradient(scale=0.9, stat = "binline", bins = 50) +
  scale_x_log10(labels = scales::label_comma(), name = var, limits = c(1,100))+
  scale_y_discrete(limits = rev(sample_metadata$Code))+
  viridis::scale_fill_viridis( option = "C", alpha = 0.7) +
  theme_ridges()+theme(legend.position = 'none')
# 
# 
# #density plot for hemoglobin
var <- "percent.hemoglobin"
submd <- combmd[,c(var,'orig.ident')]
colnames(submd)[1] <- 'var'
maxdens <- aggregate(var ~ orig.ident, submd, function(x){max(density(x)$y)})

# submd <- combmd[,c(var,'orig.ident')]
# colnames(submd)[1] <- 'var'
# repelcoords <- aggregate(var ~ orig.ident, submd, median)
# repelcoords$maxdens <- maxdens$var
# 
# dens_hemo <- ggplot(combmd, aes(x = .data[[var]]+0.01, col = orig.ident))+
#   geom_density()+
#   ggrepel::geom_text_repel(inherit.aes = F,
#                            data = repelcoords,
#                            aes(x = var, y = maxdens, label = orig.ident, color = orig.ident))+
#   scale_y_continuous(name = 'density')

dens_hemo <- ggplot(combmd, aes(x = .data[[var]]+1, y=orig.ident, fill=after_stat(log10(x))))+
  geom_density_ridges_gradient(scale=0.9, stat = "binline", bins = 50) +
  scale_x_log10(labels = scales::label_comma(), name = var,limits = c(1,100))+
  scale_y_discrete(limits = rev(sample_metadata$Code))+
  viridis::scale_fill_viridis( option = "C", alpha = 0.7) +
  theme_ridges()+theme(legend.position = 'none')




## also prep some summary plots for each sample ##

### post-fld plots

combmd <- dplyr::bind_rows(mdlist)

combmd <- combmd[combmd$filteredout == F,]

### ridgeplots / ridgeline density plots

# #density plot for nCount_RNA
var <- "nCount_RNA"

post_dens_UMI <- ggplot(combmd, aes(x = .data[[var]], y=orig.ident, fill=after_stat(log10(x))))+
  geom_density_ridges_gradient(scale=0.9, stat = "binline", bins = 50) +
  scale_x_log10(labels = scales::label_comma(), name = var,
                limits = umilims )+
  scale_y_discrete(limits = rev(sample_metadata$Code))+
  viridis::scale_fill_viridis( option = "C", alpha = 0.7) +
  theme_ridges()+theme(legend.position = 'none')


# #density plot for nFeature_RNA
var <- "nFeature_RNA"


post_dens_feature <- ggplot(combmd, aes(x = .data[[var]], y=orig.ident, fill=after_stat(log10(x))) )+
  geom_density_ridges_gradient(scale=0.9, stat = "binline", bins = 50) +
  scale_x_log10(labels = scales::label_comma(), name = var,
                limits = featlims )+
  scale_y_discrete(limits = rev(sample_metadata$Code))+
  viridis::scale_fill_viridis( option = "C", alpha = 0.7) +
  theme_ridges()+theme(legend.position = 'none')

# #density plot for mito
var <- "percent.mito"

post_dens_mito <- ggplot(combmd, aes(x = .data[[var]]+1, y=orig.ident, fill=after_stat(log10(x))))+
  geom_density_ridges_gradient(scale=0.9, stat = "binline", bins = 50) +
  scale_x_log10(labels = scales::label_comma(), name = var,
                limits = c(1,100) )+
  scale_y_discrete(limits = rev(sample_metadata$Code))+
  viridis::scale_fill_viridis( option = "C", alpha = 0.7) +
  theme_ridges()+theme(legend.position = 'none')


# #density plot for hemoglobin
var <- "percent.hemoglobin"

post_dens_hemo <- ggplot(combmd, aes(x = .data[[var]]+1, y=orig.ident, fill=after_stat(log10(x))))+
  geom_density_ridges_gradient(scale=0.9, stat = "binline", bins = 50) +
  scale_x_log10(labels = scales::label_comma(), name = var,
                limits = c(1,100) )+
  scale_y_discrete(limits = rev(sample_metadata$Code))+
  viridis::scale_fill_viridis( option = "C", alpha = 0.7) +
  theme_ridges()+theme(legend.position = 'none')







### prepare a whole dataset qc summary pdf

# adjust filter summary table colnames, too long
colnames(fs) <- gsub('auto.', '', colnames(fs))

allsampfiltsumm <- paste0(qcdir, '/AllSamples_QC_Summary.pdf')


#add plot titles

dens_UMI <-  dens_UMI + ggtitle('Pre-Filter UMI distribution plot')   
post_dens_UMI <-  post_dens_UMI + ggtitle('Post-Filter UMI distribution plot')   

dens_feature <-  dens_feature + ggtitle('Pre-Filter Unique Gene distribution plot')   
post_dens_feature <- post_dens_feature + ggtitle('Post-Filter Unique Gene distribution plot')   

dens_mito <-  dens_mito + ggtitle('Pre-Filter Percent Mito distribution plot')   
post_dens_mito <-  post_dens_mito + ggtitle('Post-Filter Percent Mito distribution plot')

dens_hemo <-   dens_hemo + ggtitle('Pre-Filter Percent Hemoglobin distribution plot')   
post_dens_hemo <- post_dens_hemo + ggtitle('Post-Filter Percent Hemoglobin distribution plot')   





pdf(allsampfiltsumm, height = 7, width = 7)


print(pdftable(fs, title = "Cell Filter Summary (cell numbers)"))


print( pdftable( round(bsl$nCount_RNA,1) , title = 'Pre-Filter UMI distribution') )

print(  dens_UMI   )
print(  post_dens_UMI   )


print( pdftable( round(bsl$nFeature_RNA,1) , title = 'Pre-Filter Unique Gene distribution') )

print(  dens_feature   )
print(  post_dens_feature  )



print( pdftable( round(bsl$perc.mito,1) , title = 'Pre-Filter Percent Mito distribution') )

print(  dens_mito  )
print(  post_dens_mito   )



print( pdftable( round(bsl$perc.hemoglobin,1) , title = 'Pre-Filter Percent Hemoglobin distribution') )

print(  dens_hemo   )
print(  post_dens_hemo   )

dev.off()


```



## Filter out poor quality cells

Sometimes poor quality cells can occur in the data due to cell membrane damage during sample preparation, etc. This can bias the downstream analysis.


```{r filtprint_mainsummary, results='asis'}





cat("\n\n

Below we show the number of cells removed with filtering. BasicFilter refers to cells failing a minimum threshold: by default, cells must have >= 500 UMIs, 200 unique genes, and <= 25% mitochondria and hemoglobin content.

Auto.complexity refers to outliers from a regression analysis modelling number of genes by number of UMIs, or the 'complexity' of the cell. Specifically we model the log of each of these, where the relationship is very close to linear. We use a double-regression strategy of both linear and loess regression, and outlier cells must have both a high linear regression Cook's distance and very low Loess negative residuals. This means that cells with a lower than expected number of genes given the number of UMIs are filtered out. Typically, this captures poor quaity cells of extreme low-complexity realy cells such as RBCs.

Auto.libsize refers to cells identified as very low outliers based on median absolute deviation from the general distribtuion of UMIs. Auto.mito refers to cells identified as high outliers based on median absolute deviation from the general distribtuion of mitochondrial content.")

knitr::kable(fs)




cat('\n\n
    
Here we show details of the filtering approach, including the minimum UMI and unique gene cutoffs, maximum percent mito and percent hemoglobin cutoffs. Additionally, we show paramters for the sample-wise cutoffs including median absolute deviation (M.A.D.) score threshold, and Loess residual threshold. These are used to make tighter cutoffs in an automated, sample-by-sample basis. The actual sample wise cutoffs are provided for each sample in a report in the QC folder called "qualitycontrol_filtering".')

knitr::kable( aflist[[1]]$allcommands )



```


### UMI distribution and filtering

Unique Molecular Identifiers (UMIs) are sequence labels that are attached to each transcript during library prep, which allow for counting unique mRNA transcripts in 10X data.


```{r filtprint_umi, results='asis'}


cat('Here we show the summary statistics for the distributions of UMIs in each sample before filtering.')

knitr::kable(bsl$nCount_RNA)

cat('#### UMI pre-filter distribution
    
Here we plot the distribution of UMIs per cell for all samples before filtering.')

print(dens_UMI)

cat('#### UMI post-filter distribution
    
Here we plot the distribution of UMIs per cell for all samples after filtering.')
print(post_dens_UMI)


```





### Unique feature (gene) distribution and filtering



```{r filtprint_feature, results='asis'}


cat('Here we show the summary statistics for the distributions of genes (or "features", as they are reffered to in Seurat and machine learning jargon) in each sample before filtering.')

knitr::kable(bsl$nFeature_RNA)


cat('#### Unique Feature pre-filter distribution

Here we plot the distribution of features per cell for all samples before filtering.')
print(dens_feature)

cat('#### Unique Feature post-filter distribution
    
Here we plot the distribution of features per cell for all samples after filtering.')
print(post_dens_feature)


```




### Mitochondrial content level filtering

The percent of mitochondrial content is used as a metric of cell quality in single-cell data. If cells are damaged during handling, they often sustain membrane tearing, which causes cytoplasmic RNA to leak, while mitochondria and mitochondrial RNA is retained. Thus, poor quality, damaged cells often have enriched mt-RNA.

```{r filtprint_mito, results='asis'}


cat('Here we show the summary statistics for the distributions of mitochondrial content in each sample before filtering.')
knitr::kable(bsl$perc.mito)


cat('#### Mito pre-filter distribution
    
Here we plot the distribution of mitochondrial content per cell for all samples before filtering.')
print(dens_mito)

cat('#### Mito post-filter distribution
    
Here we plot the distribution of mitochondrial content per cell for all samples after filtering.')
print(post_dens_mito)


```



### Hemoglobin content level filtering

Hemoglobin is expressed strongly but not exclusively by red blood cells (RBCs), which are typically removed during data generation by RBC lysis buffer, because they are extremely numerous and can overwhelm the tissue cells of interest. However, many samples will often still contain some RBCs (or many, if sample quality is poor). Removing them allows focusing in on the cells of interest.


```{r filtprint_hemo, results='asis'}


cat('Here we show the summary statistics for the distributions of hemoglobin content in each sample before filtering.')
knitr::kable(bsl$perc.hemoglobin)


cat('#### Hemoglobin pre-filter distribution
    
Here we plot the distribution of hemoglobin content per cell for all samples before filtering.')
print(dens_hemo)

cat('#### Hemoglobin post-filter distribution
    
Here we plot the distribution of hemoglobin content per cell for all samples after filtering.')
print(post_dens_hemo)


```







# Processing and analysis for each sample



As stated above, below we detail the analysis for each sample, which includes:

* Preprocessing: Normalize and scale gene expression with the Seurat SingleCellTransform (SCT) pipeline

* Dimension reduction: Principal component analysis, graph construction, clustering, and visualization via UMAP. Ideally, this step requires some hyperparameter selection, including selecting the number of PCs and Louvain clustering resolution

* Marker analysis: using a differential expression test, find the unique marker genes of each cluster

* Label transfer: from a reference single-cell dataset, quantify how much each cell resembles a known cell type from a reference dataset, such as one derived from a paper or single-cell database






## Select number of Principal Components (PCs) to use based on elbow plot

Principal Component Analysis (PCA) is important for downstream analysis including clustering and visualization with non-linear dimension reduction such as UMAP.

PCA finds high-dimensional planes which vary strongly across the cells. Essentially, each PC consists of very highly correlated genes. The first PC specifically can be thought of as a list of genes that drive together drive the most variance across cells. Each following PC has less variance.

PCA is used to help de-noising the data for downstream tasks like clustering. Individual genes can be noisy, but groups of correlated genes are less noisy.

An important caveat of PCA is that it is a linear method, in that the PC axes it finds are straight lines. This is okay for denoising genes but can often fail to capture the complexity of single-cell RNA-seq and other types of high dimensional genomic datasets. This is why the analysis does not stop at PCA but includes other more complex non-linear methods described below.

One important parameter for downstream analysis is the selection of how many PCs to use. We want to select the PCs that explain a sufficient amount of variance in the data. One way to do that is via “elbow plots” of each PC versus the standard deviation. The cutoff is made at the PC at which the SD stabilizes and becomes horizontal.

Including too few PCs can mean missing important sources of variations downstream and may result in for example, cell types being merged together in a single cluster. Conversely, including too many PCs can introduce noise into the data and result in clusters not easily explained by biology.

By default, we set the number of PCs to use as 30, which will be appropriate for most samples and is recommended as a default by the developers of SingleCellTransform. If the “Elbow” in the elbow plots strongly deviates from this, a different value may be selected and the analysis can be rerun later.



```{r preproc_individual_SCT, message='hold', results='hide', message=F, fig.keep='all'}



#clean up env
rm(aflist, bsl, combmd, 
   dens_feature, post_dens_feature,
   dens_hemo, post_dens_hemo,
   dens_mito, post_dens_mito,
   dens_UMI, post_dens_UMI,
   fs, maxdens, mdlist,
   submd, featlims, umilims)

invisible(gc(full = T, reset = F, verbose = F))


#test if force_redo is T or if saved sobj result does not exist
## if test == T, do it, if not skip it
### WILL IMPLEMENT LATER


### may implement later: read in serial, process parallel?
# readin serial, split up according to num workers 
# https://stackoverflow.com/questions/3318333/split-a-vector-into-chunks
# x = sample_metadata$code; split(x, ceiling(seq_along(x)/workernum))

# force_redo_test <- T




#read in data and run PCA

sobjlist <- lapply(sample_metadata$Code, function(code){
  
  sobjfile <- paste0(qctmpdir, '/', code, '.rds')
  # sobjfile <- paste0(outdir_indi_seuratobjs, '/SeuratObject-', code, '.rds')
  
  sobj <- readRDS(sobjfile)
  
  DefaultAssay(sobj) <- 'RNA'
  
  sobj <- SCTransform(sobj, assay = "RNA", verbose = verbose, method = 'glmGamPoi', vst.flavor='v2')
  
  sobj <- RunPCA(sobj, assay = "SCT", verbose = verbose)
  
  sobj
  
})

names(sobjlist) <- sample_metadata$Code

# #read from tmp dir
# sobjfile <- paste0(qctmpdir, '/SeuratObject-', code, '.rds')

# #remove tmp dir
unlink(qctmpdir, recursive = T)



## check elbow plot

elbowplots <- lapply(sobjlist, function(sobj){
  
  ElbowPlot(sobj, ndims = 50) + ggtitle(sobj@project.name)
  
})



```


```{r elbowplots_print, fig.height=3, fig.width=3}

#plot one at a time rather than side by side, label was getting cut off
#patchwork::wrap_plots(elbowplots)

for(i in 1:length(elbowplots)){
  print(elbowplots[[i]] + geom_vline(xintercept = pcs_indi, linetype = 'dotted', color = 'red'))
}



```





## Clustering

Once PCA is completed and the number of critical PCs is selected, we perform a number of steps that all involve grouping cells together based on shared transcriptomic patterns:

* k-nearest neighbor graph construction

* Louvain clustering

* Non-linear dimensionality reduction for visualization, such as t-SNE or UMAP


This process allows us to group cells together based on transcriptomic similarity. Louvain clustering optionally allows for input of a hyperparameter called “resolution,” with high resolution finding larger numbers of clusters. By default, we set this value to 0.5.


```{r preproc_individual_graph_cluster_umap, message='hold', results='hide', message=F, fig.keep='all'}



#clean env
rm(elbowplots)
invisible(gc(full = T, reset = F, verbose = F))


# ## using ndims_vec, continue individual sample pre-processing.
# 
# Calculate graph, clustering, and umap.

sobjlist <- lapply(sobjlist, function(sobj){
  
  # ndim_sample <- ndims_vec[sobj@project.name] #sample-wise PC selection
  ndim_sample <- pcs_indi
  
  sobj <- FindNeighbors(sobj, reduction = "pca", dims = c(1:ndim_sample), verbose = verbose)
  sobj <- FindClusters(sobj, verbose = verbose, resolution = res_indi)
  
  # #add 3d UMAP first
  # sobj <- Seurat::RunUMAP(sobj, reduction = "pca", dims = c(1:ndim_sample),
  #                         n.components = 3, 
  #                         reduction.name = 'UMAP3D', reduction.key = 'UMAP3D_')
  #add normal UMAP
  sobj <- RunUMAP(sobj, reduction = "pca", dims = c(1:ndim_sample), verbose = verbose)
  
  sobj
  
  
})

# ```




# ```{r markers_individualsamps_clusters}


# ## calulcate markers for individual sample clusters
# 
# This is parallelized with Future as per Seurat recommendations.
# Future multisession mode.

#turn off future, it seems to break things

# future::plan('multisession', workers=workernum)




# save markers
indimarkerdir <- paste0(outdir_indi, '/individualsample_clustermarkers/')

sampmarkersave <- paste0(indimarkerdir, '/markers-PCs_', pcs_indi, '-res_', res_indi, '/' )
dir.create(sampmarkersave, recursive = T)




mlist_individualsamples_clusters <- lapply(sample_metadata$Code, function(code){
  
  
  sampmarkersave_eachsamp <- paste0(sampmarkersave, code, '_clustermarkers.csv')
  
  #turn off file exists read in, too dangerous
  # if(!file.exists(sampmarkersave_eachsamp)){
  #   
  sobj <- sobjlist[[code]]
  
  m <- FindAllMarkers(sobj, only.pos = T, verbose = verbose)
  # as of Nov 9 2023 (Seurat v5): add score to markers
  m$score <- (m$pct.1 - m$pct.2) * m$avg_log2FC
  
  
  write.csv(m, sampmarkersave_eachsamp, quote = F, row.names = F)
  #   
  # } else{
  # m <- read.csv(sampmarkersave_eachsamp)
  
  
  # }
  
  return(m)
  
  
  
})

names(mlist_individualsamples_clusters) <- sample_metadata$Code



# future::plan(strategy = 'sequential')








```








```{r labeltransfermessage_1, results='asis'}



if(use_labeltransfer == T){
  
  
  text <- '## Label transfer from reference scRNA-seq data

With a reference single-cell RNA-seq dataset, we use label transfer to infer which celltypes are present in the new data.

One way to do this is via "label transfer", an integration-based machine learning method for classification. We use the [Seurat method](https://www.cell.com/cell/fulltext/S0092-8674(19)30559-8) for label transfer here.

'
  
  cat(text)
  
}



```





```{r labeltransfer}



if(use_labeltransfer == T){
  
  
  labeltransfer_outdir_indi <- paste0(outdir_indi, '/labeltransfer/')
  dir.create(labeltransfer_outdir_indi, recursive = T)
  
  reference <- readRDS(refdatapath)
  
  
  ### unfortunately, Seurat does not like underscores in feature names, so we need to replace
  if( any(grepl('_', reference$Celltype)) ){
    ct <- reference$Celltype
    ct <- as.character(ct)
    ct <- gsub('_', '-', ct)
    ct <- factor(ct, levels = names(sort(table(ct), decreasing = T)) )
    reference$Celltype <- ct
  }
  
  
  # #pre-process the reference data
  # # make sure this is done beforehand!!!
  # reference <- SCTransform(reference, ncells = 3000, verbose = verbose) %>%
  #   RunPCA(verbose = verbose) %>%
  #   RunUMAP(dims = 1:30, verbose = verbose)
  # 
  # reference$Celltype <- reference$subclass
  # 
  # refdatapath = "data/vignette/allen_cortex_preproc.rds"
  # saveRDS(reference, refdatapath)
  
  ### actually label-transfer ###
  
  
  
  sobjlist <- lapply(sobjlist, function(sobj){
    
    if(verbose == T){ message('\nLabel transfer for: ',sobj@project.name, '\n') }
    
    
    #get the integration score matrix
    
    
    # if( SeuratLabelTransfer.normalization.method == 'auto' ){
    #   
    #   
    #   if('SCT' %in% names(reference@assays) ){
    #     SeuratLabelTransfer.normalization.method <- 'SCT'
    #   } else{
    #     SeuratLabelTransfer.normalization.method <- 'LogNormalize'
    #   }
    #   
    #   
    # }
    SeuratLabelTransfer.normalization.method = 'SCT'
    
    anchors <- FindTransferAnchors(reference = reference, query = sobj, normalization.method = SeuratLabelTransfer.normalization.method, verbose = verbose)
    
    predictions.assay <- TransferData(anchorset = anchors, 
                                      refdata = reference$Celltype, 
                                      prediction.assay = T,
                                      weight.reduction = sobj[["pca"]], dims = 1:30, verbose = verbose)
    
    
    sobj[["predictions"]] <- predictions.assay
    
    
    #get the top calls for each cell
    
    topcalls <- TransferData(anchorset = anchors, refdata = reference$Celltype, prediction.assay = F,
                             weight.reduction = sobj[["pca"]], dims = 1:30, verbose = verbose)
    
    levs <- names( sort(table(topcalls$predicted.id), decreasing = T) )
    sobj$top_celltype_call_seurat <- factor(topcalls$predicted.id, levels = levs)
    sobj$top_celltype_call_seurat_score <- topcalls$prediction.score.max
    
    #add thresholded score
    md <- sobj@meta.data
    md$top_celltype_thresholded <- md$top_celltype_call_seurat
    md[md$top_celltype_call_seurat_score < 0.3, 'top_celltype_thresholded'] <- NA
    sobj$top_celltype_thresholded <- md$top_celltype_thresholded
    
    
    
    
    ### get cluster-wise labeltransfer max ###
    #get predmat
    predmat <- sobj@assays$predictions@data
    
    #drop "max"
    predmat <- predmat[1:(nrow(predmat)-1), ]
    
    #for each cluster, get max
    md <- sobj@meta.data
    clustname <- 'seurat_clusters'
    
    clustmaxlist <- lapply(levels(md[,clustname]), function(clust){
      clustcells <- rownames( md[md[,clustname] == clust,] )
      clustpred <- predmat[,colnames(predmat) %in% clustcells,drop=F]
      
      clust_avgscores <- Matrix::rowMeans(clustpred)
      maxscore <- clust_avgscores[which.max(clust_avgscores)]
      
      data.frame(cluster = clust, max = names(maxscore), score = maxscore, row.names = NULL)
      
    })
    
    clustmaxdf <- dplyr::bind_rows(clustmaxlist)
    
    
    #make a label
    clustmaxdf$label <- paste0( clustmaxdf$max)
    
    
    #uncertainty... if < 0.3, put as NA
    # if between 0.3 - 0.6, put putative
    clustmaxdf[clustmaxdf$score < 0.3,'label'] <- NA
    clustmaxdf[clustmaxdf$score >= 0.3 & clustmaxdf$score < 0.5,'label'] <- paste0( clustmaxdf[clustmaxdf$score >= 0.3 & clustmaxdf$score < 0.5,'label'],
                                                                                    '_putative')
    
    
    
    
    
    #add to metadata
    sobj$celltype_cluster_prediction <- sobj$seurat_clusters
    sobj$celltype_cluster_prediction <- plyr::mapvalues(sobj$celltype_cluster_prediction,
                                                        from = levels(sobj$celltype_cluster_prediction),
                                                        to = clustmaxdf$label)
    
    
    #write out cluster-celltype mapping
    labeltransfer_outdir_indi_code <- paste0(labeltransfer_outdir_indi, '/', sobj@project.name, '/')
    dir.create(labeltransfer_outdir_indi_code)
    
    clustcelltypemapfile <- paste0(labeltransfer_outdir_indi_code, '/ClusterCelltypeMapping.csv')
    write.csv(x=clustmaxdf,
              file = clustcelltypemapfile, 
              row.names = F, quote = F)
    
    
    sobj
    
  })
  
  
  
  
  
  
  
  
  
  # m_reference <- readRDS(m_reference)
  
  # actually we only need this later. read in at the righ time. for now save path
  m_reference_path <- m_reference
  
  
  
  
  
  
  rm(reference) #for memory saving
  
  
  # ```
  
  invisible(gc(full = T, reset = F, verbose = F))
  
  
  
}




```



# Individual sample clustering summary plots (pre-integration)

In each sample, we perform clustering and label transfer. Here we plot the clusters and cluster markers for each sample. This can help identify which cell types are present in each sample.


```{r summaryplots_individualsamples, message=FALSE, warning=F, results='hide', fig.show='hide'}





#save each as pdf, one per sample...
dir.create( paste0(outdir_indi, '/individualsample_plots/') , recursive = T)


#prep summary plots for each sample
# umap of clusters
# insert QC per cluster plots here?
# cluster markers

summaryplots_individualsamples <- lapply( sobjlist , function(sobj){
  
  # set up title
  sampname <- sobj@project.name
  
  #get markers
  m <- mlist_individualsamples_clusters[[sampname]]
  
  
  
  #clusters plot
  # for auto plotting with manually set res, need to use paste here...
  
  plottingvar <- paste0('SCT_snn_res.', res_indi)
  
  #dimplot of clusters
  d1_a <- wrap_plots(
    DimPlot(sobj, group.by = plottingvar, label = T, repel = T)
  ) + plot_annotation(title = sampname, caption = 'Louvain Clusters plotted on UMAP')
  
  
  
  # ## 3d umap ##
  # embs <- as.data.frame(sobj@reductions$UMAP3D@cell.embeddings)
  # embs <- cbind(embs, sobj$seurat_clusters); colnames(embs)[4] <- 'seurat_clusters'
  # embs$cluster_color <- plyr::mapvalues(embs$seurat_clusters, 
  #                                       from = levels(embs$seurat_clusters), 
  #                                       to = scales::hue_pal()(length(levels(embs$seurat_clusters))))
  # #add labels...
  # labdf <- aggregate(cbind(UMAP3D_1, UMAP3D_2, UMAP3D_3) ~ seurat_clusters, embs, median)
  # labdf$cluster_color <- levels(embs$cluster_color)
  # 
  # #store inrgedients, run rgl when its time to print
  # three_d_umap_ingrdients <- list(embs = embs, labdf=labdf)
  # 
  # 
  
  
  # qc plots, do it with patchwork
  d0 <- wrap_plots(ncol = 2, list(
    VlnPlot(sobj, 'nCount_RNA', pt.size = 0.1)+NoLegend() ,
    VlnPlot(sobj, 'nFeature_RNA', pt.size = 0.1)+NoLegend(),
    VlnPlot(sobj, 'percent.mito', pt.size = 0.1)+NoLegend() ,
    VlnPlot(sobj, 'percent.hemoglobin', pt.size = 0.1)+NoLegend()
  )) + plot_annotation(title = sampname)
  
  
  # cluster markers
  
  
  DefaultAssay(sobj) <- 'SCT'
  n <- 5
  top <- m %>% group_by(cluster) %>% top_n(n = n, wt = score)
  genes <- top$gene
  #make sure genes are in 
  if( any( !(genes %in% rownames(sobj@assays$SCT@scale.data)) ) ){
    
    #try getresidual...
    missinggenes <- genes[!(genes %in% rownames(sobj@assays$SCT@scale.data))]
    sobj <- GetResidual(sobj, missinggenes, na.rm = F, replace.value = T)
    
    #it can be complicated doing this after integration, some genes are NAs... 
    scgem <- sobj@assays$SCT@scale.data
    
    if( any( !complete.cases(scgem) ) ){
      scgem <- scgem[complete.cases(scgem),]
      top <- top[top$gene %in% rownames(scgem),]
      sobj@assays$SCT@scale.data <- scgem
    }
    rm(scgem)
    
  }
  
  #prep heatmap
  top <- top[top$gene %in% rownames(sobj),]
  gem <- sobj@assays$SCT@scale.data
  gem <- gem[match(top$gene, rownames(gem)),]
  #annot for clusters
  #first order gem by cluster...
  md <- sobj@meta.data
  md <- md[order(md$seurat_clusters),]
  gem <- gem[,match(rownames(md), colnames(gem))]
  clust_bc <- setNames(md$seurat_clusters,
                       nm = colnames(gem)
  )
  col_clust <- setNames(scales::hue_pal()(length(levels(sobj$seurat_clusters))),
                        nm = levels(sobj$seurat_clusters))
  ha_clust <- ComplexHeatmap::HeatmapAnnotation(Cluster = clust_bc, col = list(Cluster = col_clust), show_legend = F)
  #annot for markers
  #set genes according to ct_ordered
  top$cluster <-factor(top$cluster, levels=unique(top$cluster))
  # top <- top[order(top$cluster),]
  gem <- gem[match(top$gene, rownames(gem)),]
  ct_gene <- setNames(top$cluster,
                      nm=top$gene)
  col_gene <- col_clust
  col_gene <- col_gene[names(col_gene) %in% top$cluster]
  ha_genes <- ComplexHeatmap::rowAnnotation(Cluster = ct_gene, col = list(Cluster = col_gene),
                                            show_annotation_name=F)
  #restrict range
  gem[gem>5] <- 5
  gem[gem<-5] <- -5
  
  #actual heatmap
  hm <- ComplexHeatmap::Heatmap(gem,
                                # column_title = 'Integrated clusters',
                                column_labels = rep('', ncol(gem)),
                                row_names_gp = grid::gpar(fontsize = 5),
                                column_split = md$seurat_clusters,
                                row_split = top$cluster,
                                row_title_gp = grid::gpar(fontsize = 5),
                                row_gap = unit(0.8, "mm"), 
                                column_gap = unit(0.8, "mm"),
                                row_title_rot = 0,
                                column_title_rot = 45,
                                column_title_gp = grid::gpar(fontsize = 7),
                                name = 'Scaled\nExpression',
                                cluster_columns = F,
                                cluster_rows = F,
                                top_annotation = ha_clust,
                                left_annotation = ha_genes,
                                use_raster = F)
  
  # invisible(hm <- draw(hm, column_title = sampname))
  
  
  list(
    d1_a=d1_a,
    # three_d_umap_ingrdients = three_d_umap_ingrdients,
    
    hm=hm,
    d0=d0
  )
  
} )


#name the list elements, one per sample

names(summaryplots_individualsamples) <- sapply(sobjlist, function(sobj){sobj@project.name}, simplify = T)





#save as PDFs
lapply(names(summaryplots_individualsamples), function(sampname){
  pdf( paste0(outdir_indi, '/individualsample_plots/', sampname, '.pdf'), width = 9, height = 9 )
  
  print( summaryplots_individualsamples[[sampname]]$d1_a )
  print( summaryplots_individualsamples[[sampname]]$hm )
  print( summaryplots_individualsamples[[sampname]]$d0 )
  
  dev.off()
  
  
})




if(use_labeltransfer == T){
  
  
  
  ## plots of cell type predictions from label transfer
  
  ctplots_individualsamples <- lapply( sobjlist, function(sobj){
    
    #set up title
    sampname <- sobj@project.name
    
    
    
    
    #clusters plot
    # for auto plotting with manually set res, need to use paste here...
    
    plottingvar <- paste0('SCT_snn_res.', res_indi)
    
    #dimplot of clusters
    d1_a <- wrap_plots(
      DimPlot(sobj, group.by = plottingvar, label = T, repel = T)
    ) + plot_annotation(title = sampname, caption = 'Louvain Clusters plotted on UMAP')
    
    
    
    
    ### prep the Celltype Plots ("ctplots")
    
    
    # violinplots of all celltypes
    
    #get exp of the celltypes
    rs <- Matrix::rowSums(sobj@assays$predictions@data)
    rs <- head( rs , -1)
    
    #keep only celltypes that are exp
    rs <- sort(rs[rs>0], decreasing = T)
    ct_in <- names(rs)
    
    #plots of all celltypes in data...
    DefaultAssay(sobj) <- 'predictions'
    
    ct_plots <- lapply(setNames(ct_in,ct_in), function(ct){
      #FeaturePlot(sobj, features = ct) + ggtitle(sampname)
      
      ct_plot <-  VlnPlot(sobj, ct)+NoLegend()+ylab('Prediction score') + 
        plot_annotation(title = sampname)
      
      return(ct_plot)
      
    })
    DefaultAssay(sobj) <- 'SCT'
    
    
    
    
    #heatmap of the prediction scores per cluster
    # use scaled values, comparable between clusters
    # get avgs
    avgs <- AverageExpression(sobj, assays = 'predictions', return.seurat = F)
    #remove max
    avgs <- head( as.data.frame(avgs) , -1)
    # remove empty prediction rows with all 0s
    avgs <- avgs[Matrix::rowSums(avgs)>0,]
    #make column titles nicer
    colnames(avgs) <- gsub('predictions.', 'cluster_', colnames(avgs))
    #format as numeric matrix
    avgs <- as.matrix(avgs)
    ### scale --> this emphasizes diffs between clusters, seems to put related cell types together
    avgs <- t(scale(t(avgs)))
    #select middle value  for color scale
    medval <- mean(avgs)
    #plot it
    hm_ctscores <- ComplexHeatmap::Heatmap(avgs,
                                           name = 'Scaled\nmean prediction\nscores per cluster',
                                           column_title = sampname,
                                           rect_gp = grid::gpar(col = "white", lwd = 0.5),
                                           circlize::colorRamp2(c(min(avgs), medval, max(avgs)), c("blue", "white", "red")))
    
    
    
    
    
    #for dotplot, add dendrogram and row label order
    # it may throw a warning about drawing plot first etc, 
    #shouldn't be an issue if we set seed, which we did
    suppressWarnings(
      dend <- row_dend(hm_ctscores)
    )
    
    #get ordered row labels for dotplot and other plots
    suppressWarnings(
      ct_ordered <- rownames(hm_ctscores@matrix)[ComplexHeatmap::row_order(hm_ctscores)]
    )
    
    
    nicedend <- ggdendro::ggdendrogram(rev(dend), rotate = T) +   
      scale_y_reverse(expand = c(0.05, 0))+
      theme(axis.text.y = element_blank(),
            axis.text.x = element_blank())
    
    dp_ctscores <- DotPlot(sobj, assay = 'predictions', rev(ct_ordered)) + 
      coord_flip() + 
      theme(axis.title.y=element_blank(),
            axis.text.y =  element_text(hjust = 0),
            axis.text.x = element_text(size=5) )+
      scale_color_gradient2(low = 'blue', high = 'red', mid = 'grey')+
      xlab(label = 'Cluster')+
      guides(color = guide_colorbar(title = "Scaled Average\nPrediction Score"))
    
    dp_ctscores <- patchwork::wrap_plots(list(nicedend, dp_ctscores), widths = c(0.2,1))
    
    
    
    
    
    # heatmap of reference markers
    m_reference <- readRDS(m_reference_path)
    
    #MAKE SURE ONLY POS MARKERS
    m_reference <- m_reference[m_reference$avg_log2FC > 0,]
    
    # add score for sorting
    m_reference$score <- (m_reference$pct.1 - m_reference$pct.2) * m_reference$avg_log2FC
    
    
    #make sure to remove underscores, since seurat doesn't like it in label transfer feature names
    m_ref_small <- m_reference
    
    lt_ref_levs <- levels(m_ref_small$cluster)
    lt_ref_levs <- gsub('_', '-', lt_ref_levs)
    m_ref_small$cluster <- plyr::mapvalues(m_ref_small$cluster, from = levels(m_ref_small$cluster), lt_ref_levs)
    
    m_ref_small <- m_ref_small[m_ref_small$gene %in% rownames(sobj),]
    m_ref_small <- m_ref_small[m_ref_small$cluster %in% ct_in,]
    n <- 5
    top <- m_ref_small %>% group_by(cluster) %>% top_n(n = n, wt = score)
    
    genes <- top$gene
    
    
    #make sure genes are in 
    if( any( !(genes %in% rownames(sobj@assays$SCT@scale.data)) ) ){
      missinggenes <- genes[!(genes %in% rownames(sobj@assays$SCT@scale.data))]
      sobj <- GetResidual(sobj, genes)
    }
    
    #prep heatmap
    top <- top[top$gene %in% rownames(sobj),]
    gem <- sobj@assays$SCT@scale.data
    gem <- gem[match(top$gene, rownames(gem)),]
    
    #annot for clusters
    #first order gem by cluster...
    md <- sobj@meta.data
    md <- md[order(md$seurat_clusters),]
    gem <- gem[,match(rownames(md), colnames(gem))]
    
    clust_bc <- setNames(md$seurat_clusters,
                         nm = colnames(gem)
    )
    
    col_clust <- setNames(scales::hue_pal()(length(levels(sobj$seurat_clusters))),
                          nm = levels(sobj$seurat_clusters))
    
    ha_clust <- ComplexHeatmap::HeatmapAnnotation(Cluster = clust_bc, 
                                                  col = list(Cluster = col_clust),
                                                  show_legend = F
    )
    
    
    
    #annot for markers
    
    #set genes according to ct_ordered
    top$cluster <-factor(top$cluster, levels=ct_ordered)
    top <- top[order(top$cluster),]
    gem <- gem[match(top$gene, rownames(gem)),]
    
    ct_gene <- setNames(top$cluster,
                        nm=top$gene)
    coul <- RColorBrewer::brewer.pal(8, "Set2") 
    coul <- colorRampPalette(coul)(length(unique(top$cluster)))
    col_gene <- setNames(coul, nm = unique(top$cluster))
    
    ha_genes <- ComplexHeatmap::rowAnnotation(Celltype = ct_gene, col = list(Celltype = col_gene),
                                              show_annotation_name=F)
    
    
    #restrict range
    gem[gem>5] <- 5
    gem[gem<-5] <- -5
    
    
    #actual heatmap
    hm_refmarkers <- ComplexHeatmap::Heatmap(gem,
                                             #column_title = sampname,
                                             column_labels = rep('', ncol(gem)),
                                             row_names_gp = grid::gpar(fontsize = 5),
                                             column_split = md[,paste0('SCT_snn_res.', res_indi)],
                                             row_split = top$cluster,
                                             row_title_gp = grid::gpar(fontsize = 5),
                                             row_gap = unit(0.8, "mm"), 
                                             column_gap = unit(0.8, "mm"),
                                             column_title_rot = 45,
                                             column_title_gp = grid::gpar(fontsize = 7),
                                             row_title_rot = 0,
                                             name = 'Scaled\nExpression',
                                             cluster_columns = F,
                                             cluster_rows = F,
                                             top_annotation = ha_clust,
                                             left_annotation = ha_genes,
                                             use_raster = F)
    
    
    # hm_refmarkers <- draw(hm_refmarkers, column_title = sampname)
    
    
    
    #try to average the matrix
    avgl <- lapply(levels(md$seurat_clusters), function(clust){
      mdc <- md[md$seurat_clusters==clust,]
      gemc <- gem[,colnames(gem) %in% rownames(mdc)]
      avg <- matrix(rowMeans(gemc), 
                    dimnames = list(rownames(gem), clust))
      avg
    })
    avg <- do.call('cbind',avgl)
    
    #need to re-prep column annot
    clust_bc <- factor(str_sort(colnames(avg), numeric = T), levels = str_sort(colnames(avg), numeric = T))
    
    col_clust <- setNames(scales::hue_pal()(length(levels(sobj$seurat_clusters))),
                          nm = levels(sobj$seurat_clusters))
    
    ha_clust <- ComplexHeatmap::HeatmapAnnotation(Cluster = clust_bc, col = list(Cluster = col_clust), show_legend = F)
    
    
    hm_refmarkers_avg <- ComplexHeatmap::Heatmap(avg,
                                                 #column_title = sampname,
                                                 row_names_gp = grid::gpar(fontsize = 6),
                                                 column_split = factor(str_sort(colnames(avg), numeric = T), levels = str_sort(colnames(avg), numeric = T)), 
                                                 column_names_gp = grid::gpar(fontsize = 6),
                                                 column_title_rot = 45,
                                                 column_names_rot = 0, 
                                                 
                                                 row_split = top$cluster,
                                                 row_title_gp = grid::gpar(fontsize = 6),
                                                 row_gap = unit(0.5, "mm"), 
                                                 column_gap = unit(0.5, "mm"),
                                                 row_title_rot = 0,
                                                 name = 'Scaled\nExpression',
                                                 cluster_columns = F,
                                                 cluster_rows = F,
                                                 top_annotation = ha_clust,
                                                 left_annotation = ha_genes,
                                                 use_raster = F)
    
    
    # hm_refmarkers_avg <- draw(hm_refmarkers_avg, column_title = sampname)
    
    
    
    
    #top cell type plots
    plottingvar <- 'top_celltype_thresholded'
    
    
    
    d2_a <- wrap_plots(
      DimPlot(sobj, group.by = plottingvar, label = T, repel = T)
    ) + plot_annotation(title = sampname)
    
    d2_b <- wrap_plots(
      FeaturePlot(sobj, 'top_celltype_call_seurat_score')) + plot_annotation(title = sampname)
    
    #alluvial plot, clusters to cell types
    md <- sobj@meta.data
    labelsdf <- md[,c('seurat_clusters', 'top_celltype_thresholded')]
    
    
    ap <- wrap_plots( alluvialplot(labelsdf, repel = T, direction='y')
    ) + plot_annotation(title = sampname)
    
    
    
    ## read in cluster CT mapping
    #write out cluster-celltype mapping
    labeltransfer_outdir_indi_code <- paste0(labeltransfer_outdir_indi, '/', sobj@project.name, '/')
    
    clustcelltypemapfile <- paste0(labeltransfer_outdir_indi_code, '/ClusterCelltypeMapping.csv')
    
    clustmaxdf <- read.csv(clustcelltypemapfile)
    
    
    #also plot the cluster celltype call on dimplot
    d3 <- DimPlot(sobj, group.by = 'celltype_cluster_prediction', label = T, repel = T)
    
    
    
    #using heatmap dendrogram, order in a cool way
    suppressWarnings(
      ct_ordered <- rownames(hm_ctscores@matrix)[ComplexHeatmap::row_order(hm_ctscores)]
    )
    
    ct_plots <- ct_plots[ct_ordered] 
    
    
    
    list(d1_a=d1_a, 
         hm_ctscores=hm_ctscores,
         dp_ctscores=dp_ctscores,
         hm_refmarkers=hm_refmarkers,
         hm_refmarkers_avg=hm_refmarkers_avg,
         
         d2_a=d2_a,
         d2_b=d2_b,
         ap=ap,
         
         d3 = d3,
         clustmaxdf=clustmaxdf,
         
         ct_plots=ct_plots
    )
    
    
  })
  
  
  #name them with the code names
  
  names(ctplots_individualsamples) <- sapply(sobjlist, function(sobj){sobj@project.name}, simplify = T)
  
  #save as PDFs
  
  lapply(names(ctplots_individualsamples), function(sampname){
    
    #print to labeltransfer df
    
    labeltransfer_outdir_indi_code <- paste0(labeltransfer_outdir_indi, '/', sampname, '/')
    pdf( paste0(labeltransfer_outdir_indi_code, '/LabelTransferSummaryPlots.pdf'), width = 9, height = 9 )
    
    ## print each but make sure table gets printed as a pdftable ##
    ctplots_thissamp <- ctplots_individualsamples[[sampname]]
    for(i in 1:length(ctplots_thissamp) ){
      
      if(names(ctplots_thissamp)[i] == 'clustmaxdf'){
        print( scDAPP::pdftable(ctplots_thissamp[[i]], title = 'Cluster-Celltype Mapping') )
      } else{
        print(ctplots_thissamp[[i]])
      }
      
    }
    
    dev.off()
    
    return(sampname)
    
  })
  
  
  
}

```






```{r summaryplots_individualsamples_print_summary, fig.keep='all', message=FALSE, results='asis'}





#print to report

# do this in a way that creates a section for each sample...
# https://stackoverflow.com/questions/36674824/use-loop-to-generate-section-of-text-in-rmarkdown

template <- "


## Sample %s


" # don't forget the newline




for (i in 1:length( names(summaryplots_individualsamples) ) ) {
  sampname <- names(summaryplots_individualsamples)[i]
  
  cat(sprintf(template, sampname))
  
  
  sampsumplots <- summaryplots_individualsamples[[i]]
  
  
  
  #plot each plot one at a time with appropriate label
  
  plotlab <- "


### UMAP of clusters

Here we plot a UMAP of the Louvain clusters for this sample.


"
  
  cat( plotlab )
  print( sampsumplots$d1_a )
  
  
  
  #   ## 3d umap ##
  #   
  #   
  #   plotlab <- "
  # 
  # 
  # ### 3D UMAP of clusters
  # 
  # Here we plot a 3D UMAP of the Louvain clusters for this sample.
  # 
  # 
  # "
  #   
  #   cat( plotlab )
  #   print( sampsumplots$d1_a )
  #   
  #   embs <- as.data.frame(sobj@reductions$UMAP3D@cell.embeddings)
  #   embs <- cbind(embs, sobj$seurat_clusters); colnames(embs)[4] <- 'seurat_clusters'
  #   embs$cluster_color <- plyr::mapvalues(embs$seurat_clusters, 
  #                                         from = levels(embs$seurat_clusters), 
  #                                         to = scales::hue_pal()(length(levels(embs$seurat_clusters))))
  #   #add labels...
  #   labdf <- aggregate(cbind(UMAP3D_1, UMAP3D_2, UMAP3D_3) ~ seurat_clusters, embs, median)
  #   labdf$cluster_color <- levels(embs$cluster_color)
  #   
  #   #store inrgedients, run rgl when its time to print
  #   three_d_umap_ingrdients <- summaryplots_individualsamples$three_d_umap_ingrdients
  #   embs <- three_d_umap_ingrdients$embs
  #   labdf <- three_d_umap_ingrdients$labdf
  #   
  #   
  #   UMAP3D_1 = embs$UMAP3D_1; UMAP3D_2 = embs$UMAP3D_2; UMAP3D_3 = embs$UMAP3D_3
  #   rgl::plot3d(UMAP3D_1, UMAP3D_2, UMAP3D_3, col = embs$cluster_color)
  #   rgl::text3d(labdf$UMAP3D_1, labdf$UMAP3D_2, labdf$UMAP3D_3, texts = labdf$seurat_clusters, 
  #               adj = c(2,2,2))
  #   
  #   
  
  
  plotlab <- "


### Heatmap of cluster markers

Here we plot the top 5 marker genes of each cluster as identified by wilcoxon test. Sometimes, clusters may share the same markers, which may indicate the clusters are similar, such as subtypes of the same cell type (for example, CD4 vs CD8 T cells).


"
  
  cat( plotlab )
  print( sampsumplots$hm )
  
  
  plotlab <- "


### QC plots 

Here we plot some QC information, including the number of UMIs (nCount_RNA) and the number of unique genes (nFeature_RNA). Very low values may indicate a low number of cells in a specific area or low quality. If the clustering and markers look very strange, the quality metrics may help diagnose issues by indicating a cluster of poor quality cells.


"
  
  cat( plotlab )
  print( sampsumplots$d0 )
  
}





```




```{r labeltransfermessage_2, results='asis'}


if(use_labeltransfer == T){
  
  
  text <- '
# Individual sample label transfer cell type predictions

For each sample we perform label transfer from a reference single-cell RNA-seq dataset. Here, we plot the results of the label transfer. Using a prior single-cell RNAseq dataset, we learn which cell types are present in the current data.

Using label transfer, we can get a score for each cell type in the reference dataset. A high score indicates a strong and confident match, while a low score indicates a match of low confidence and may represent a cell type that was not captured in the reference.

Note that we apply a label transfer score cutoff of 0.3. If the cells are below this, they are marked as NA. These may represent cells missing from the reference.


It can be complex and time-consuming to analyze each sample individually before integration; however, the reward is often worth the effort. Characterizing each sample allows us to assess the presence of cell types in each sample carefully. For example, we may find that all the samples contain neuron cells, while only one sample may contain macrophage cells, but other samples do not. This is useful for interpreting the downstream results of differential expression across samples; for example, it would be wise to focus on a comparative analysis of the cell types in all samples (neurons), and simply note that macrophages are present in some but missing in other samples.

Additionally, it is also useful to observe how the cell types are related to one another in the individual samples. We may observe that immune cell types like T cells and B cells may cluster closely together, while very different cell types, such as neurons and endothelial cells, may cluster far apart. Identifying such clustering patterns in individual samples may help identify cases of "over-integration" or other issues.
'
  
  cat(text)
  
  
}

```




```{r summaryplots_individualsamples_print_celltypeplots, fig.keep='all', message=FALSE, results='asis'}




if(use_labeltransfer == T){
  
  #print to report
  
  # do this in a way that creates a section for each sample...
  # https://stackoverflow.com/questions/36674824/use-loop-to-generate-section-of-text-in-rmarkdown
  
  template_samples <- "


## Sample %s


"
  
  
  template_plots <- "


### %s


"
  
  template_celltypes <- "


#### %s


"
  
  
  for (i in 1:length( names(ctplots_individualsamples) ) ) {
    sampname <- names(ctplots_individualsamples)[i]
    
    cat(sprintf(template_samples, sampname))
    
    
    ctplotlist <- ctplots_individualsamples[[i]]
    
    #print them, with titles
    
    
    plotlab <- "


### Heatmap of label transfer cell type scores

Here we plot the label transfer scores, which are used to predict cell types from the reference single-cell RNAseq dataset. The values are scaled, allowing easy comparison across clusters.


"
    
    cat( plotlab )
    print(ctplotlist$hm_ctscores)
    
    
    
    plotlab <- "


### Dotplot of label transfer cell type scores

Here we plot the label transfer scores, which are used to predict cell types from the reference single-cell RNAseq dataset. The values are scaled, allowing easy comparison across clusters. It is very similar to the heatmap above. 

However, the dotplot also includes information about how many cells in the cluster express the cell type score. A big dot indicates many cells in that cluster express it at non-zero level. A big gray dot indicates widespread, low score among cells. A big red dot indicates widespread, high score among cells. A blue dot indicates relatively low score. A small dot indicates few cells express the score.


"
    
    cat( plotlab )
    
    print(ctplotlist$dp_ctscores)
    
    
    
    
    
    plotlab <- "


### Heatmap of reference cell type markers

Here we plot the top 5 reference celltype markers as sorted by average log2 fold change. The markers are derived from the reference dataset. Since these are the top specific markers of each cell type in the reference, their expression pattern should match clusters with a high label transfer score for each given cell type. For example, a cluster with high T cell score should highly express T cell markers.



"
    
    cat( plotlab )
    
    print(ctplotlist$hm_refmarkers)
    
    
    
    plotlab <- "


### Heatmap of reference cell type markers averaged across clusters

Here we plot the top 5 reference cell type markers by average log2 fold change, this time using the average cluster expression. The markers are derived from the reference dataset. Using averages allows us to easily see which clusters highly or lowly express the reference cell type markers.




"
    
    cat( plotlab )
    
    print(ctplotlist$hm_refmarkers_avg)
    
    
    
    
    
    plotlab <- "


### UMAP of top scoring celltypes

The top scoring celltype for each cell is plotted on the UMAP.



"
    
    cat( plotlab )
    
    print(ctplotlist$d2_a)
    
    
    plotlab <- "


### UMAP of label transfer scores

The scores of the cell types are plotted on the UMAP. This shows how confident the prediction is. If the score is low, it may be that the cells present in this dataset are missing from the reference.


"
    
    cat( plotlab )
    
    
    
    print(ctplotlist$d2_b)
    
    
    
    plotlab <- "


### Alluvial plot mapping between Louvain clusters to top celltypes

This alluvial plot maps cluster labels to top celltype labels for each cell. This can be useful to identify general trends of celltype score per cluster.
The top-scoring cell type is plotted, but some cells and clusters may contain a mix of cell types.



"
    
    cat( plotlab )
    
    
    print(ctplotlist$ap)
    
    
    
    plotlab <- '


### Table showing cluster-celltype mapping

We apply an ad-hoc method to extend the label transfer from individual cells (default) across entire clusters. We do this by taking the average score of each cell type score in the cluster and choosing the max. This can help simplify the analysis and can be less noisy by sharing information across cells, but may also hide intra-cluster variability, such as particular sub-clusters which may correspond to distinct cell sub-types.

We also apply a thresholding approach such that clusters with a max score of less than 0.3 are considered non-transferrable and marked as NA (not applicable). These may reflect clusters of cells which are not in the reference dataset.
Additionally, clusters with a score between 0.3 - 0.5 are marked with the suffix "_putative" to indicate the somewhat uncertain status. All cluster markers should be carefully inspected and checked for cell type, independnetly of the label transfer results.

'
    
    cat( plotlab )
    
    clustmaxprint <- ctplotlist$clustmaxdf
    clustmaxprint$score <- round(clustmaxprint$score, digits = 5)
    print(knitr::kable(clustmaxprint))
    
    
    
    plotlab <- "


### UMAP of cluster-celltype mapping

As described above, we extend the label transfer prediction from individual cells to whole clusters in order to denoise and simplify the analysis. Here, rather than plotting the individual cell predictions, we plot the cluster-level predictions.



"
    
    cat( plotlab )
    
    
    print(ctplotlist$d3)
    
    
    
    plotlab <- "


### Violin plots for each cell type

Here we plot a violin plot for each cell type to analyze the label transfer scores type in detail.


"
    
    cat( plotlab )
    
    for(j in 1:length(ctplotlist$ct_plots) ){
      
      ctname <- names(ctplotlist$ct_plots[j])
      
      cat(sprintf(template_celltypes, ctname))
      
      print( ctplotlist$ct_plots[[j]] )
      
    }
    
    
    
    
    
    
  }
  
  
  
}



```















# Integration of samples

Here, we combine all of the samples into a single unified dataset.

“Integration” refers to the process of combining together the data from individual samples with batch correction. Typically, library prep is done one sample at a time, which may introduce bias due to technical artifacts associated with processing for that sample, i.e., particular reagent lot used, slightly longer incubation periods, slightly more reads sequenced, etc. To combine samples, we thus apply special batch-correction procedures. The method for doing that here relies on Reference Principal Component Integration, implemented in the RISC package [(Liu, Zheng et al Nat Biotech 2021)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8456427/). This approach exploits the fact that cells from the same type typically have similar transcriptomic patterns, and then tries to match the patterns.

Ultimately, the goal of integration is to minimize technical noise and maximize shared biological signals, the strongest of which is typically cell type.

Integration can be contrasted with “concatenation,” which involves simply merging the samples without any batch correction. If there are strong batch effects in the data, this method may result in clusters driven not by cell type but by the sample of origin (i.e., cluster 1 is all cells from sample 1, cluster 2 is all cells from sample 2).





```{r integration_riscprep, message=F, results='hide', warning=F}


# before integrating, add a few important columns to each sobj metadata
# "sample" column --> switch to Code
# "condition" column
# barcode column


#add sample to each sobj
codes <- sample_metadata$Code

sobjlist <- lapply(codes, function(code){
  
  sample_metadata_code <- sample_metadata[sample_metadata$Code == code,]
  
  sobj <- sobjlist[[code]]
  sobj$orig.ident <- code
  sobj$Code <- code
  sobj$Sample <- sample_metadata_code$Sample
  sobj
})

names(sobjlist) <- codes


#add a condition column
sobjlist <- lapply(names(sobjlist), function(sampname){
  
  cond <- sample_metadata[sample_metadata$Code == sampname,"Condition"]
  
  sobj <- sobjlist[[sampname]]
  sobj$Condition <- cond
  sobj
  
})

names(sobjlist) <- codes


#add a barcode column
sobjlist <- lapply(names(sobjlist), function(sampname){
  
  
  sobj <- sobjlist[[sampname]]
  md <- sobj@meta.data
  md <- cbind(rownames(md), md)
  colnames(md)[1] <- 'Barcode'
  sobj@meta.data <- md
  sobj
  
  
})

names(sobjlist) <- codes





# clean up env before doing this
rm(ctplotlist, ctplots_individualsamples, elbowplots, m_reference,
   cutoffplots, cutoffs, sampsumplots, 
   elbowplots,
   mlist_individualsamples_clusters, 
   qc_vln_feature, qc_vln_umi,
   summaryplots_individualsamples)



invisible(gc(full = T, reset = F, verbose = F))




#### save each object and get the metadata

#add clusters to each sobjlist object and then save each object
tmpobjdir <- paste0(outdir_indi, '/.tmp_Seurat_objects/')
dir.create(tmpobjdir, recursive = T)

mdlist <- lapply(sample_metadata$Code, function(code){
  
  sobj <- sobjlist[[code]]
  saveRDS(sobj, paste0(tmpobjdir, '/', code, '.rds'))
  
  md <- sobj@meta.data
  
  return(md)
  
})


names(mdlist) <- sample_metadata$Code



### qc purposes, read in  --> keep commented
# sobjlist <- lapply(sample_metadata$Code, function(code){
#   
#   message(code)
#   sobj <- readRDS( paste0(tmpobjdir, '/', code, '.rds') )
#   
#   sobj
#   
# })
# names(sobjlist) <- sample_metadata$Code



#remove gene list and seurat objects form env and purge
rm(sobjlist)
invisible(gc(full = T, reset = F, verbose = F))


#read in raw seurat objects, filter using mdlist
if(input_seurat_obj == T){
  
  matlist <- lapply(sample_metadata$Code, function(code){
    
    #get md for this object
    md <- mdlist[[code]]
    
    #read raw matrix
    samp <- sample_metadata[sample_metadata$Code == code,'Sample']
    
    #for HTO, we will assume saved objects
    sobjfile <- paste0(datadir, '/', samp, '.rds')
    sobj <- readRDS(sobjfile)
    
    #get RNA counts matrix
    # mat0 <- sobj@assays$RNA@counts
    mat0 <- GetAssayData(sobj, assay = 'RNA', layer = 'counts')
    
    
    #filter using sobj metadata
    mat0 <- mat0[,match(rownames(md), colnames(mat0))]
    
    
    return(mat0)
    
  })
} else{
  
  
  
  
  matlist <- lapply(sample_metadata$Code, function(code){
    
    #get md for this object
    md <- mdlist[[code]]
    
    #read raw matrix
    samp <- sample_metadata[sample_metadata$Code == code,'Sample']
    datafp <- paste0(datadir, '/', samp)
    # if on hpc, use below
    # datafp <- paste0(datadir, '/', samp, '/outs/')
    
    # for the dl data, we need to find the filepath
    h5_filename <- grep(pattern = 'filtered_feature_bc_matrix.h5',
                        list.files(datafp, recursive = T, full.names = T),
                        value = T)
    
    #get RNA counts matrix
    mat0 <- Read10X_h5(h5_filename)
    
    #filter using sobj metadata
    mat0 <- mat0[,match(rownames(md), colnames(mat0))]
    
    
    return(mat0)
    
  })
  
}

names(matlist) <- sample_metadata$Code

# keep intersect genes; will only remove genes if aligned with different GTFs
var0 <- Reduce(intersect, lapply(matlist, FUN = rownames))
matlist <- lapply(matlist, function(mat){ mat[match(var0, rownames(mat)), ] })
rm(var0)

#join matrices, filter genes from joint mat and proceed with union
bigmat <- do.call(cbind, matlist)

#get num cells expressing
num_nonzeros <- tabulate(bigmat@i + 1)

#get joint filtered genes as those exp by  >= 3 cells
joint_filt_genes <- rownames(bigmat)[num_nonzeros >= 3]



# prep the risc objects #
risclist <- lapply(sample_metadata$Code, function(code){
  
  #get md and mat0
  md <- mdlist[[code]]
  mat0 <- matlist[[code]]
  
  #subset matrix using jointly filtered genes
  mat0 <- mat0[rownames(mat0) %in% joint_filt_genes,]
  mat0 <- mat0[match(joint_filt_genes, rownames(mat0)),]
  
  
  #prep metadata for risc
  coldata0 <- md
  rm(md)
  
  #get barcodes, strip numeric suffix, and add samplename prefix
  barcodes <- stringr::str_split_fixed(rownames(coldata0), '-', 2)[,1]
  barcodes <- paste0(coldata0$orig.ident, '.',barcodes)
  
  coldata0 <- cbind(barcodes, coldata0)
  rm(barcodes)
  
  
  #make the rowdatadf...
  rowdata0 = data.frame(Symbol = rownames(mat0), row.names = rownames(mat0))
  
  #make the risc object
  ### make sure to set is.filter = F or it will still use sample-specific filtering
  dat0 = readsc(mat0, coldata0, rowdata0, is.filter = F)
  
  rm(mat0, rowdata0, coldata0)
  
  return(dat0)
})

names(risclist) <- sample_metadata$Code


## save matlist, we will add it to RNA assay later ##
outdir_int_objects <- paste0(outdir_int, '/data_objects/')
dir.create(outdir_int_objects, recursive = T)
saveRDS(matlist, paste0(outdir_int_objects, '/.concatmatrix.rds'))

#clean env
rm(bigmat, num_nonzeros, joint_filt_genes, matlist, mdlist)
invisible(gc(full = T, reset = F, verbose = F))






#### process each sample ####
# make sure to set ncore to 1 for all; we'll parallelize across samples for this

#prepare the RISC functions
process0 <- function(obj0){
  
  # Filter cells and genes
  message('scFilter')
  obj0 = RISC::scFilter(obj0, min.UMI = 0, max.UMI = Inf, min.gene = 0, min.cell = 0, is.filter = F)
  
  # Normalize the raw counts
  message('scNormalize')
  obj0 = RISC::scNormalize(obj0, ncore = 1)
  
  # Find highly variable genes
  message('scDisperse')
  obj0 = RISC::scDisperse(obj0)
  
  return(obj0)
}




### process each sample with RISC functions, in parallel
cl <- parallel::makeCluster(workernum)
doParallel::registerDoParallel(cl)

risclist <- foreach(dat0 = risclist,
                    .packages = c('RISC')) %dopar% 
  {
    return( process0(dat0) )
  }


parallel::stopCluster(cl)
invisible(gc(full = T, reset = F, verbose = F))
names(risclist) <- sample_metadata$Code



## variable genes - we still use all genes.
#get the intersect of gene names
var0 <- Reduce(intersect, lapply(risclist, FUN = function(x){x@rowdata$Symbol}))




#run inplot - just to show the plot later
#pdf null prevents premature plot showing
pdf( NULL )

ip <- InPlot(risclist, var.gene = var0, Std.cut = 0.95, ncore = workernum) 
ip <- patchwork::wrap_plots(ip)

dev.off()



### reference- either user-defined, or guess

if( !(is.null(risc_reference)) ){
  
  
  
  #write some text about which one was selected
  #cat()
  
  
  #if provided, we need the numeric index of which sample was given
  
  #it can be either sample or code name
  if(any(risc_reference %in% sample_metadata$Code)){
    ref <- grep(risc_reference, sample_metadata$Code)
  }
  
  #it can be either sample or code name
  if(any(risc_reference %in% sample_metadata$Sample)){
    ref <- grep(risc_reference, sample_metadata$Code)
  }
  
} 


#if not provided, still do automated guess but just use the provided one
# inplot is not automated and does not suggest which sample to use.
# instead, we use the one with most clusters, given that
# all samples were processed otherwise identically (same PCs and resolution)


# get num clusters from each sample
numclusts <- sapply(risclist, function(dat0){
  length(unique(dat0@coldata$seurat_clusters))
})

# get cell num score; higher cell num is prioritized
numcells_per_sample <- sapply(risclist, function(dat0){
  nrow(dat0@coldata)
})
numcells_per_sample <- numcells_per_sample / max(numcells_per_sample)

#multipy number of cluste4rs by cell num score
numclusts <- numclusts * numcells_per_sample

#average each cluster and get averaged variance?
# do NOT use pseudobulk, which adds up
pbvar <- sapply(risclist, function(dat0){
  
  mat <- dat0@assay$logcount
  md <- dat0@coldata
  
  #pseudobulk
  pb <- pseudobulk(obj = mat, metadata = md, grouping_colname_in_md = 'seurat_clusters')
  
  #average: divide pseudobulk columns by num cells
  numcells <- table(md$seurat_clusters)
  pb <- sweep(pb, 2, numcells, FUN = '/')
  
  clustervar <- apply(pb, 2, function(x){var(x)})
  
  mean(clustervar)
  
})

#multiply number of clusts * average of cluster variance
refscore <- numclusts * pbvar



### try to divide by KS? ###



#autoselect ref
maxautoscore <- which.max(refscore)

# set reference as autoselected; only if not provided
if( is.null(risc_reference) ){
  ref <- maxautoscore
}



#need to rearrange the list...
# the reference must be the first list element...
if(ref != 1){
  
  data0 <- list(risclist[[ref]])
  names(data0) <- names(risclist)[ref]
  
  for(i in 1:length(risclist)){
    if(i != ref){
      name = names(risclist)[i]
      data0[[name]] <- risclist[[i]]
    }
    
  }
  
} else{
  data0 <- risclist
}

rm(risclist)
invisible(gc(full = T, reset = F, verbose = F))


```


```{r integration_multiint, message=F, results='hide', warning=F}



### actual integration ###
#set "eigens", num PCs to use for integration
eigens <- pcs_int

#actually integrate
data0 = scMultiIntegrate(
  objects = data0, eigens = eigens, add.Id = NULL, var.gene = var0,
  # method = "RPCI", 
  align = 'OLS', npc = 50, adjust = TRUE,
  ncore = workernum, 
  #do.fast = "AUTO"
)


rm(var0)
invisible(gc(full = T, reset = F, verbose = F))


```






```{r integration_postproc, message=F, results='hide', warning=F}


# integrated UMAP
data0 = scUMAP(data0, npc = eigens, use = "PLS")

### integrated clustering ####
## AS OF JUL 5 2023 USE scDAPP::scCluster_louvain_res()
# UPDATE MAR 14 2024 - RISC 1.7 NOW USES RESOLUTION PARAMETER
# ALSO RISC AND MY SCDAPP FUNCTION BROKE WITH IGRAPH UPDATE, FIXED IN 1.7
# integrated clustering
# neighbor = 10 is default... maybe make it a variable too...?
data0 <- scCluster(data0,
                   slot = "cell.pls",
                   method = 'louvain',
                   npc = eigens,
                   res = res_int,
                   neighbor = RISC_louvain_neighbors
)

### remap clust, biggest to smallest...
#get risc clust
rc <- data0@coldata$Cluster

#sort by biggest to smallest
bs <- sort(table(rc), decreasing = T)
rc <- plyr::mapvalues(rc, from = names(bs), to = c(1:length(bs)) )
rc <- factor(rc, levels = 1:length(bs))

#set to object
data0@coldata$Cluster <- rc
rm(rc,bs)

# data0 = scDAPP::scCluster_louvain_res(object = data0,
#                                       slot = "cell.pls",
#                                       # method = 'louvain',
#                                       npc = eigens,
#                                       resolution = res_int,
#                                       neighbor = RISC_louvain_neighbors,
# )








#save it
outdir_int_objects <- paste0(outdir_int, '/data_objects/')
dir.create(outdir_int_objects)
saveRDS(data0, paste0(outdir_int_objects, '/RISC-object_integrated.rds'))



#cluster markers --> do this with seurat instead
# riscmarkertime <- proc.time()
# risc_clustermarkers = AllMarker(data0, ncore = workernum)
# riscmarkertime <- proc.time() - riscmarkertime
# takes about an hour, even with parallelization

#get matrix, umap, md, pca, etc; then put into seurat object

mat <- do.call(cbind, data0@assay$logcount)
md <- data0@coldata
umap <- data0@DimReduction$cell.umap
pca <- data0@DimReduction$cell.pls


#rename "Cluster" to "RISC cluster"
risc_clust_lab <- paste0('RISC_Louvain_npc', pcs_int, '_res', res_int)
colnames(md)[ncol(md)] <- risc_clust_lab
clustname <- risc_clust_lab

#make obj
sobjint <- CreateSeuratObject(counts = CreateAssayObject(data=mat),
                              assay = 'RISC', project = 'Integrated',
                              meta.data = md
)

#add dim reducs
sobjint[['umap']] <-  CreateDimReducObject(umap, assay = 'RISC', key = 'UMAP_')
sobjint[['pca']] <-  CreateDimReducObject(pca, assay = 'RISC', key = 'PCA_')





#clean env
rm(umap,pca,mat,md, data0)
invisible(gc(full = T, reset = F, verbose = F))

### find markers ###

#set default levels
sobjint <- SetIdent(sobjint, value = sobjint@meta.data[,risc_clust_lab])
sobjint$seurat_clusters <- sobjint@meta.data[,risc_clust_lab]


#save object
saveRDS(sobjint, paste0(outdir_int_objects, '/Seurat-object_integrated.rds'))


#save markers
intmarkersdir <- paste0(outdir_int, '/markergenes_intclusters/')
dir.create(intmarkersdir, recursive = T)
intmarkersfile <- paste0(intmarkersdir, '/intmarkers-npc', pcs_int, '-res', res_int,  '.csv')

#get markers, parallelized
# TURN OFF PAR FOR NOW, it seems to break things
# ALSO MAKE SURE NOT TO DO READ IN THING IN CASE OF CLUSTERING DIFFS
# future::plan('multisession', workers=workernum)

# if(!file.exists(intmarkersfile)){
#   
#   #Seurat clusters
#   seuratmarkertime <- proc.time()
# m_integrated_clusters <- FindAllMarkers(sobjint,
#                                         only.pos = T)
#   seuratmarkertime <- proc.time() - seuratmarkertime
#   
#   
#   # future::plan(strategy = 'sequential')
#   
#   # takes about an hour, future parallel is not stable and cause memory crash
#   
#   
# write.csv(m_integrated_clusters, intmarkersfile, quote = F, row.names = F)
#   
#   
# } else{
# m_integrated_clusters <- read.csv(intmarkersfile)
# 
# }


m_integrated_clusters <- FindAllMarkers(sobjint,
                                        only.pos = T)

# as of Nov 9 2023 (Seurat v5): add score to markers
m_integrated_clusters$score <- (m_integrated_clusters$pct.1 - m_integrated_clusters$pct.2) * m_integrated_clusters$avg_log2FC


write.csv(m_integrated_clusters, intmarkersfile, quote = F, row.names = F)


```





``` {r update_indi_objects, message=F, results='hide', warning=F}




#remove sobjint for now, so we can read in each seurat object and save them.
# we'll read back in after
#add int clusters to each sobj in sobjlist with intmd
intmd <- sobjint@meta.data
rm(sobjint)
invisible(gc(full = T, reset = F, verbose = F))


## WE ALSO NEED PREDICTIONS ASSAY FROM INDIVIDUAL OBJECTS
# only if labeltransfer == T

#add clusters to each sobjlist object and then save each object
# shoudl already be created above...
outdir_indi_seuratobjs <- paste0(outdir_indi, '/processed_Seurat_objects/')
dir.create(outdir_indi_seuratobjs, recursive = T)

predictionmats <- lapply(sample_metadata$Code, function(code){
  
  #read in from temp dir
  sobj <- readRDS(paste0(tmpobjdir, '/', code, '.rds'))
  
  #subset intmd for this sample
  intmd_sub <- intmd[intmd$Code == code,]
  
  #get md for this sample from sobjlist (pre-int sobj)
  md <- sobj@meta.data
  
  #make sure they match (very likely they always will...?)
  intmd_sub <- intmd_sub[match(md$Barcode, intmd_sub$scBarcode),]
  
  #get clusters; clustname defined above
  sobj@meta.data[,clustname] <- intmd_sub[,clustname]
  
  #save each sample obj to proc obj dir
  invisible( saveRDS(sobj,
                     paste0(outdir_indi_seuratobjs, '/SeuratObject-', code, '.rds'))
  )
  
  if(use_labeltransfer == T){
    #return prediction assay with proper risc barcodes
    predictionmat <- sobj@assays$predictions@data
    colnames(predictionmat) <- intmd_sub$Barcode
    return(predictionmat)
  } else{
    return(code)
  }
  
})



#remove temp folder
unlink(tmpobjdir, recursive = T)



#read sobjint back in
sobjint <- readRDS( paste0(outdir_int_objects, '/Seurat-object_integrated.rds') )


#add predictions assay to integrated seurat object
if(use_labeltransfer==T){
  
  #combine prediction matrices and add to seurat obj
  predmat <- as(as.matrix(dplyr::bind_cols(predictionmats)), "sparseMatrix")
  rownames(predmat) <- rownames(predictionmats[[1]])
  
  #match order of barcodes
  predmat <- predmat[,match(rownames(intmd), colnames(predmat))]
  
  predassay <- CreateAssayObject(data=predmat)
  
  sobjint[['predictions']] <- predassay
  
  
  
  ### also predict int cluster-celltype mapping ###
  
  #get predmat
  predmat <- sobjint@assays$predictions@data
  
  #drop "max"
  predmat <- predmat[1:(nrow(predmat)-1), ]
  
  #for each cluster, get max
  md <- sobjint@meta.data
  clustname <- 'seurat_clusters'
  
  clustmaxlist <- lapply(levels(md[,clustname]), function(clust){
    clustcells <- rownames( md[md[,clustname] == clust,] )
    clustpred <- predmat[,colnames(predmat) %in% clustcells,drop=F]
    
    clust_avgscores <- Matrix::rowMeans(clustpred)
    maxscore <- clust_avgscores[which.max(clust_avgscores)]
    
    data.frame(cluster = clust, max = names(maxscore), score = maxscore, row.names = NULL)
    
  })
  
  clustmaxdf <- dplyr::bind_rows(clustmaxlist)
  
  
  #make a label
  clustmaxdf$label <- paste0( clustmaxdf$max)
  
  
  #uncertainty... if < 0.3, put as NA
  # if between 0.3 - 0.6, put putative
  clustmaxdf[clustmaxdf$score < 0.3,'label'] <- NA
  clustmaxdf[clustmaxdf$score >= 0.3 & clustmaxdf$score < 0.5,'label'] <- paste0( clustmaxdf[clustmaxdf$score >= 0.3 & clustmaxdf$score < 0.5,'label'],
                                                                                  '_putative')
  
  
  
  
  
  
  #add to metadata
  sobjint$INT_celltype_cluster_prediction <- sobjint$seurat_clusters
  sobjint$INT_celltype_cluster_prediction <- plyr::mapvalues(sobjint$INT_celltype_cluster_prediction,
                                                             from = levels(sobjint$INT_celltype_cluster_prediction),
                                                             to = clustmaxdf$label)
  
  
  
  #write out cluster-celltype mapping
  labeltransfer_outdir_int <- paste0(outdir_int, '/labeltransfer/')
  dir.create(labeltransfer_outdir_int)
  
  clustcelltypemapfile <- paste0(labeltransfer_outdir_int, '/IntClusterCelltypeMapping.csv')
  write.csv(x=clustmaxdf,
            file = clustcelltypemapfile, 
            row.names = F, quote = F)
  
  
  
  rm(predmat,predictionmats, predassay, clustmaxlist)
  
}




## clean up env
rm(predictionmats, intmd)

invisible(gc(full = T, reset = F, verbose = F))


## readin concat matrix with raw counts and put in seurat object ##
matlist <- readRDS( paste0(outdir_int_objects, '/.concatmatrix.rds') )

#for each matrix, change cell names to match seurat object
set_code <- paste0(sobjint$Set, '_', sobjint$Code)
set_code <- unique(set_code)
set_code <- str_split_fixed(set_code,pattern =  '_', n=2)
matlist <- lapply(1:length(matlist), function(i){
  mat <- matlist[[i]]
  code <- names(matlist)[i]
  set <- set_code[set_code[,2] == code,1]
  colnames(mat) <- paste0(set, '_', colnames(mat))
  mat
  
})

#join matrices, filter genes from joint mat and proceed with union
bigmat <- do.call(cbind, matlist)

#get num cells expressing
num_nonzeros <- tabulate(bigmat@i + 1)

#get joint filtered genes as those exp by  >= 3 cells
joint_filt_genes <- rownames(bigmat)[num_nonzeros >= 3]

# filter by these
bigmat <- bigmat[rownames(bigmat) %in% joint_filt_genes,]

# filter cells and match order to seurat
bigmat <- bigmat[,match(colnames(sobjint), colnames(bigmat))]
colnames(bigmat) <- colnames(sobjint)

#add as RNA assay
rnaassay <- Seurat::CreateAssayObject(counts = bigmat)
sobjint[['RNA']] <- rnaassay
DefaultAssay(sobjint) <- 'RNA'
sobjint <- NormalizeData(sobjint, assay = 'RNA')
DefaultAssay(sobjint) <- 'RISC'

#add in expm1 risc values to counts slot of risc assay
sobjint@assays$RISC@counts <- expm1(sobjint@assays$RISC@data)

#unlink temp concat mat
unlink( paste0(outdir_int_objects, '/.concatmatrix.rds') )

#clean env
invisible(gc(full = T, reset = F, verbose = F))
rm(bigmat, joint_filt_genes, num_nonzeros, matlist)




#factorize sample column to make sure it's the right order...
sobjint$Code <- factor(sobjint$Code, levels = sample_metadata$Code)

#factorize condiiton column to make sure it's the right order...
sobjint$Condition <- factor(sobjint$Condition, levels = levels(sample_metadata$Condition))


#update saved sobjint with predictions assay
saveRDS(sobjint,  paste0(outdir_int_objects, '/Seurat-object_integrated.rds') )


## clean up env
rm(predictionmats, intmd)

invisible(gc(full = T, reset = F, verbose = F))





```





## Selection of reference sample for integration

RISC requires the selection of a reference sample from among the dataset. The optimal reference sample is one that has the most diversity of celltypes.


```{r integration_riscref_ip, results='asis', fig.height=10, fig.width=10}



plotlab <- '
One way to select the reference sample is manual inspection of the "InPlot". This plot consists of three panels. The top panel is the most important, and shows the number of clusters detected in each sample across a range of different PC values. Essentially, this is a proxy of the number of cell types detected in the dataset, and the sample with most clusters should be selected as the reference. The second panel allows selection of the optimal PC value to use and the amount of variance each PC has for each sample, with good samples having a higher score (indicating more diversity). The third panel indicates bias of the gene signatures, samples with high scores here should not be selected as the reference.



'

cat(plotlab)

print(ip)



plotlab <- '

## Automated RISC reference selection

We have implemented an automated reference selection algorithm, extending the intuition laid out above. This is based on two metrics: 1) the number of clusters, and 2) the cluster-moderated sample variance. 

It is not enough to pick the sample with the most clusters, because sometimes samples have ties in the number of clusters, and cluster number alone can be proportional to number of cells. Thus, we weight the number or clusters by a metric of diversity in the sample which we call the cluster-moderated sample variance.

The cluster-moderated sample variance is calculated first by clustering each sample (ie, using the Seurat Louvain clusters described above), then averaging the sample at the cluster level. Then, the variance of each cluster is calculated, and finally, the mean of the cluster-wise variance is taken. 

Then, to calculate the reference selection score, we multiply the number of clusters per sample, times a relative weighing metric based on the number of cells in each sample relative to the sample with the most cells in the dataset (biggest gets a one, sampe with half cells of biggest gets a 0.5); then we multiply this value by the cluster-moderated variance described above.


We show here the resulting reference scores. The top score is selected as the reference. Please note that the autoselection is experimental, so if the score and selected reference deviates from InPlot, we recommend re-running the pipeline and manually selecting the optimal reference.

In this dataset, sample **%s** would be selected as the reference.


'

cat(sprintf(plotlab, names(maxautoscore)))

#format ref scores as data.frame
refscoredf <- data.frame('RefScore' = refscore)
refscoredf$Max <- ''
refscoredf[maxautoscore,'Max'] <- '*'
refscoredf$RefScore <- round(refscoredf$RefScore, 5)

#add "set"
refscoredf$Set <- paste0("Set-", 1:nrow(refscoredf))

#add sample and remove rownames
refscoredf$Code <- rownames(refscoredf)
rownames(refscoredf) <- NULL

#reorder
refscoredf <- refscoredf[,c('Code', 'Set', 'RefScore', 'Max')]


knitr::kable(refscoredf)





if( !(is.null(risc_reference)) ){
  
  plotlab <- '
## Manual reference selection: %s

In this analysis, sample %s was manually selected as the reference sample. Sample %s will be used as the reference, regardless of the auto-selection described above.

'
  
  cat(sprintf(plotlab, risc_reference, risc_reference, risc_reference))
  
}


```







```{r integration_plots, results='hide', message=FALSE, warning=F}




#set summaryplot dir
outdir_int_plots <- paste0(outdir_int, '/integration_summaryplots/')
dir.create(outdir_int_plots)


#first, plot the ref selection stuff: inplot and autoselect

pdf( paste0(outdir_int_plots, 'RISC_reference_selection.pdf'), height = 8, width = 6  )
print(ip)
if( !is.null(risc_reference) ){
  print(
    pdftable(refscoredf, 
             title = paste0('Manual reference selected\nSample: ',
                            risc_reference)
    )
  )
} else{
  print(
    pdftable(refscoredf, 
             title = paste0('RISC reference\nautoselection')
    )
  )
}

dev.off()


## for each sample get int clusters for alluvial plot
mdint <- sobjint@meta.data


## plots of the integrated data

#umap of clusters
clustname <- risc_clust_lab
d1_int <- DimPlot(sobjint, label = T, repel = T, group.by = clustname)

#umap of samples
d2_int <- DimPlot(sobjint, group.by = 'Code', split.by = 'Condition', ncol = 2) + 
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1.1))


#conditions
dcond <- DimPlot(sobjint, group.by = 'Condition')

#split by conditions
dcond_split <- DimPlot(sobjint, label = T, repel = T, 
                       group.by = clustname,
                       split.by = 'Condition',
                       ncol=2)+
  theme(panel.border = element_rect(colour = "black", fill=NA, size=1.1))

#heatmap of cluster markers

DefaultAssay(sobjint) <- 'RISC'

n <- 5
top <- m_integrated_clusters %>% group_by(cluster) %>% top_n(n = n, wt = score)

genes <- top$gene

#scale the relevant genes
sobjint <- ScaleData(sobjint, features = genes, verbose = verbose)


# #make sure genes are in 
# if( any( !(genes %in% rownames(sobjint@assays$SCT@scale.data)) ) ){
#   
#   #try getresidual...
#   missinggenes <- genes[!(genes %in% rownames(sobjint@assays$SCT@scale.data))]
#   sobjint <- GetResidual(sobjint, missinggenes, na.rm = F, replace.value = T)
#   
#   #it can be complicated doing this after integration, some genes are NAs... 
#   scgem <- sobjint@assays$SCT@scale.data
#   
#   if( any( !complete.cases(scgem) ) ){
#     scgem <- scgem[complete.cases(scgem),]
#     top <- top[top$gene %in% rownames(scgem),]
#     sobjint@assays$SCT@scale.data <- scgem
#   }
#   rm(scgem)
#   
# }



#prep heatmap
top <- top[top$gene %in% rownames(sobjint),]
gem <- sobjint@assays$RISC@scale.data
gem <- gem[match(top$gene, rownames(gem)),]

#annot for clusters
#first order gem by cluster...
md <- sobjint@meta.data
md <- md[order(md$seurat_clusters),]
gem <- gem[,match(rownames(md), colnames(gem))]

clust_bc <- setNames(md$seurat_clusters,
                     nm = colnames(gem)
)

col_clust <- setNames(scales::hue_pal()(length(levels(sobjint$seurat_clusters))),
                      nm = levels(sobjint$seurat_clusters))

ha_clust <- ComplexHeatmap::HeatmapAnnotation(Cluster = clust_bc, col = list(Cluster = col_clust), show_legend = F)



#annot for markers

#set genes according to ct_ordered
top$cluster <-factor(top$cluster, levels=unique(top$cluster))
# top <- top[order(top$cluster),]
gem <- gem[match(top$gene, rownames(gem)),]

ct_gene <- setNames(top$cluster,
                    nm=top$gene)

col_gene <- col_clust
col_gene <- col_gene[names(col_gene) %in% top$cluster]

ha_genes <- ComplexHeatmap::rowAnnotation(Cluster = ct_gene, col = list(Cluster = col_gene),
                                          show_annotation_name=F)




#restrict range
gem[gem>5] <- 5
gem[gem<-5] <- -5



#actual heatmap
hm_int <- ComplexHeatmap::Heatmap(gem,
                                  # column_title = 'Integrated clusters',
                                  column_labels = rep('', ncol(gem)),
                                  row_names_gp = grid::gpar(fontsize = 5),
                                  column_split = md$seurat_clusters,
                                  row_split = top$cluster,
                                  row_title_gp = grid::gpar(fontsize = 5),
                                  row_gap = unit(0.8, "mm"), 
                                  column_gap = unit(0.8, "mm"),
                                  row_title_rot = 0,
                                  column_title_rot = 45,
                                  column_title_gp = grid::gpar(fontsize = 7),
                                  name = 'Scaled\nExpression',
                                  cluster_columns = F,
                                  cluster_rows = F,
                                  top_annotation = ha_clust,
                                  left_annotation = ha_genes,
                                  use_raster = F)




### marker avergae heatmap ###
#try to average the matrix
avgl <- lapply(levels(md$seurat_clusters), function(clust){
  mdc <- md[md$seurat_clusters==clust,]
  gemc <- gem[,colnames(gem) %in% rownames(mdc)]
  avg <- matrix(rowMeans(gemc), 
                dimnames = list(rownames(gem), clust))
  avg
})
avg <- do.call('cbind',avgl)

#need to re-prep column annot
clust_bc <- factor(str_sort(colnames(avg), numeric = T), levels = str_sort(colnames(avg), numeric = T))

col_clust <- setNames(scales::hue_pal()(length(levels(sobjint$seurat_clusters))),
                      nm = levels(sobjint$seurat_clusters))

ha_clust <- ComplexHeatmap::HeatmapAnnotation(Cluster = clust_bc, col = list(Cluster = col_clust), show_legend = F)


hm_int_avg <- ComplexHeatmap::Heatmap(avg,
                                      # column_title = 'Integrated clusters',
                                      row_names_gp = grid::gpar(fontsize = 6),
                                      column_names_gp = grid::gpar(fontsize = 6),
                                      column_split = factor(str_sort(colnames(avg), numeric = T), levels = str_sort(colnames(avg), numeric = T)), 
                                      column_title_rot = 0,
                                      column_names_rot = 0, 
                                      
                                      row_split = top$cluster,
                                      row_title_gp = grid::gpar(fontsize = 6),
                                      row_gap = unit(0.5, "mm"), 
                                      column_gap = unit(0.5, "mm"),
                                      row_title_rot = 0,
                                      name = 'Scaled\nExpression',
                                      cluster_columns = F,
                                      cluster_rows = F,
                                      top_annotation = ha_clust,
                                      left_annotation = ha_genes,
                                      use_raster = F)




## update Aug 8 add qc plots

int_qc_vln <- wrap_plots(ncol = 2, list(
  VlnPlot(sobjint, 'nCount_RNA', pt.size = 0.1)+NoLegend() ,
  VlnPlot(sobjint, 'nFeature_RNA', pt.size = 0.1)+NoLegend() ,
  VlnPlot(sobjint, 'percent.mito', pt.size = 0.1)+NoLegend() ,
  VlnPlot(sobjint, 'percent.hemoglobin', pt.size = 0.1)+NoLegend()
))









# DefaultAssay(sobjint) <- 'integrated'





### alluvial plot of condition to cluster

md <- sobjint@meta.data

labelsdf <- md[,c("Condition", clustname)]

ap_cond_to_clust <- alluvialplot(labelsdf)


### alluvial plot of sample to cluster
# do this for each condition separately

mdint <- sobjint@meta.data
ap_samp_to_clust_list <- lapply(unique(sample_metadata$Condition), function(cond){
  
  md <- mdint[mdint$Condition == cond,]
  
  
  labelsdf <- md[,c("Code", clustname)]
  #avoid relevlling, same colors for all gets confusing
  # levels(labelsdf$Code) <- levels(labelsdf$Code)[levels(labelsdf$Code) %in% labelsdf$Code]
  # labelsdf$Code <- factor(labelsdf$Code, levels = levels(labelsdf$Code)[levels(labelsdf$Code) %in% labelsdf$Code] )
  
  ap_samp_to_clust <- alluvialplot(labelsdf) + labs(title = cond) + NoLegend()
  
  return(ap_samp_to_clust)
  
})
names(ap_samp_to_clust_list) <- unique(sample_metadata$Condition)
ap_samp_to_clust <- wrap_plots(ap_samp_to_clust_list)





#loop thru each code, make alluvialplot of indi to int cluster
mdint <- sobjint@meta.data
indi_int_clust_ap_list <- lapply(sample_metadata$Code, function(code){
  md <- mdint[mdint$Code == code,]
  
  indiclustname <- paste0("SCT_snn_res.", res_indi)
  intclustname <- risc_clust_lab <- paste0('RISC_Louvain_npc', pcs_int, '_res', res_int)
  labelsdf <- md[,c(indiclustname, intclustname)]
  
  labelsdf[,1] <- factor(labelsdf[,1], levels = stringr::str_sort(unique(labelsdf[,1]), numeric = T) )
  
  names(labelsdf)[1] <- 'Individual Clusters'
  
  
  
  indi_int_clust_ap <- scDAPP::alluvialplot(labelsdf)
  
  
  return(indi_int_clust_ap)
  
})
names(indi_int_clust_ap_list) <- sample_metadata$Code


summaryplots_integrated <- list(dcond=dcond,
                                d2_int=d2_int,
                                d1_int=d1_int,
                                dcond_split=dcond_split,
                                ap_cond_to_clust=ap_cond_to_clust,
                                ap_samp_to_clust=ap_samp_to_clust,
                                hm_int=hm_int,
                                hm_int_avg=hm_int_avg,
                                int_qc_vln=int_qc_vln,
                                indi_int_clust_ap_list = indi_int_clust_ap_list)




### save pdfs to a subdir of outdir_int
outdir_int_plots <- paste0(outdir_int, '/integration_summaryplots/')

dir.create(outdir_int_plots)

pdf( paste0(outdir_int_plots, '/summaryplots_integrated.pdf'), height = 9, width=9 )

print(summaryplots_integrated)

dev.off()






### cell type plots

if(use_labeltransfer == T){
  
  
  
  #umap of cell type calls (calculated in individual samples)
  d3_int <- DimPlot(sobjint, label = T, repel = T, group.by = 'top_celltype_thresholded')
  
  #umap showing top cell type call score (calculated in individual samples)
  d4_int <- FeaturePlot(SetIdent(sobjint, value = 'top_celltype_thresholded', ), label = T, repel = T, features = 'top_celltype_call_seurat_score')
  
  
  #heatmap of the prediction scores per cluster
  # use scaled values, comparable between clusters
  # get avgs
  avgs <- AverageExpression(sobjint, assays = 'predictions', return.seurat = F)
  #remove max
  avgs <- head( as.data.frame(avgs) , -1)
  # remove empty prediction rows with all 0s
  avgs <- avgs[Matrix::rowSums(avgs)>0,]
  #make column titles nicer
  colnames(avgs) <- gsub('predictions.', 'cluster_', colnames(avgs))
  #format as numeric matrix
  avgs <- as.matrix(avgs)
  ### scale --> this emphasizes diffs between clusters, seems to put related cell types together
  avgs <- t(scale(t(avgs)))
  #select middle value  for color scale
  medval <- mean(avgs)
  #plot it
  hm_ctscores <- ComplexHeatmap::Heatmap(avgs, 
                                         name = 'Scaled\nmean prediction\nscores per cluster', 
                                         column_title = 'Integrated', 
                                         rect_gp = grid::gpar(col = "white", lwd = 0.5), 
                                         circlize::colorRamp2(c(min(avgs), medval, max(avgs)), c("blue", "white", "red")))
  
  
  
  #for dotplot, add dendrogram and row label order
  # it may throw a warning about drawing plot first etc, 
  #shouldn't be an issue if we set seed, which we did
  suppressWarnings(
    dend <- row_dend(hm_ctscores)
  )
  
  #get ordered row labels for dotplot and other plots
  suppressWarnings(
    ct_ordered <- rownames(hm_ctscores@matrix)[ComplexHeatmap::row_order(hm_ctscores)]
  )
  
  
  nicedend <- ggdendro::ggdendrogram(rev(dend), rotate = T) +   
    scale_y_reverse(expand = c(0.05, 0))+
    theme(axis.text.y = element_blank(),
          axis.text.x = element_blank())
  
  dp_ctscores <- DotPlot(sobjint, assay = 'predictions', rev(ct_ordered)) + 
    coord_flip() + 
    theme(axis.title.y=element_blank(),
          axis.text.y =  element_text(hjust = 0),
          axis.text.x = element_text(size=5) )+
    scale_color_gradient2(low = 'blue', high = 'red', mid = 'grey')+
    xlab(label = 'Cluster')+
    guides(color = guide_colorbar(title = "Scaled Average\nPrediction Score"))
  
  
  dp_ctscores <- patchwork::wrap_plots(list(nicedend, dp_ctscores), widths = c(0.3,1))
  
  
  
  #get exp of the celltypes
  rs <- Matrix::rowSums(sobjint@assays$predictions@data)
  rs <- head( rs , -1)
  
  #keep only celltypes that are exp
  rs <- sort(rs[rs>0], decreasing = T)
  ct_in <- names(rs)
  
  
  # heatmap of reference markers
  m_reference <- readRDS(m_reference_path)
  
  #MAKE SURE ONLY POS MARKERS
  m_reference <- m_reference[m_reference$avg_log2FC > 0,]
  
  # add score for sorting
  m_reference$score <- (m_reference$pct.1 - m_reference$pct.2) * m_reference$avg_log2FC
  
  
  
  #make sure to remove underscores, since seurat doesn't like it in label transfer feature names
  m_ref_small <- m_reference
  
  
  
  lt_ref_levs <- levels(m_ref_small$cluster)
  lt_ref_levs <- gsub('_', '-', lt_ref_levs)
  m_ref_small$cluster <- plyr::mapvalues(m_ref_small$cluster, from = levels(m_ref_small$cluster), lt_ref_levs)
  
  m_ref_small <- m_ref_small[m_ref_small$gene %in% rownames(sobjint),]
  m_ref_small <- m_ref_small[m_ref_small$cluster %in% ct_in,]
  n <- 5
  top <- m_ref_small %>% group_by(cluster) %>% top_n(n = n, wt = score)
  
  genes <- top$gene
  
  
  #scale the relevant genes
  sobjint <- ScaleData(sobjint, features = genes, verbose = verbose)
  
  #make sure genes are in 
  # if( any( !(genes %in% rownames(sobjint@assays$SCT@scale.data)) ) ){
  #   missinggenes <- genes[!(genes %in% rownames(sobjint@assays$SCT@scale.data))]
  #   sobjint <- GetResidual(sobjint, genes)
  # }
  
  #prep heatmap
  top <- top[top$gene %in% rownames(sobjint),]
  gem <- sobjint@assays$RISC@scale.data
  gem <- gem[match(top$gene, rownames(gem)),]
  
  #annot for clusters
  #first order gem by cluster...
  md <- sobjint@meta.data
  md <- md[order(md$seurat_clusters),]
  gem <- gem[,match(rownames(md), colnames(gem))]
  
  clust_bc <- setNames(md$seurat_clusters,
                       nm = colnames(gem)
  )
  
  col_clust <- setNames(scales::hue_pal()(length(levels(sobjint$seurat_clusters))),
                        nm = levels(sobjint$seurat_clusters))
  
  ha_clust <- ComplexHeatmap::HeatmapAnnotation(Cluster = clust_bc, col = list(Cluster = col_clust), show_legend = F)
  
  
  
  #annot for markers
  
  #set genes according to ct_ordered
  top$cluster <-factor(top$cluster, levels=ct_ordered)
  top <- top[order(top$cluster),]
  gem <- gem[match(top$gene, rownames(gem)),]
  
  ct_gene <- setNames(top$cluster,
                      nm=top$gene)
  coul <- RColorBrewer::brewer.pal(8, "Set2") 
  coul <- colorRampPalette(coul)(length(unique(top$cluster)))
  col_gene <- setNames(coul, nm = unique(top$cluster))
  
  ha_genes <- ComplexHeatmap::rowAnnotation(Celltype = ct_gene, col = list(Celltype = col_gene),
                                            show_annotation_name=F)
  
  
  #restrict range
  gem[gem>5] <- 5
  gem[gem<-5] <- -5
  
  
  #actual heatmap
  hm_refmarkers <- ComplexHeatmap::Heatmap(gem,
                                           # column_title = 'Integrated clusters',
                                           column_labels = rep('', ncol(gem)),
                                           row_names_gp = grid::gpar(fontsize = 5),
                                           column_split = md$seurat_clusters,
                                           row_split = top$cluster,
                                           row_title_gp = grid::gpar(fontsize = 5),
                                           row_gap = unit(0.8, "mm"), 
                                           column_gap = unit(0.8, "mm"),
                                           row_title_rot = 0,
                                           column_title_rot = 45,
                                           column_title_gp = grid::gpar(fontsize = 7),
                                           name = 'Scaled\nExpression',
                                           cluster_columns = F,
                                           cluster_rows = F,
                                           top_annotation = ha_clust,
                                           left_annotation = ha_genes,
                                           use_raster = F)
  
  
  
  
  #try to average the matrix
  avgl <- lapply(levels(md$seurat_clusters), function(clust){
    mdc <- md[md$seurat_clusters==clust,]
    gemc <- gem[,colnames(gem) %in% rownames(mdc)]
    avg <- matrix(rowMeans(gemc), 
                  dimnames = list(rownames(gem), clust))
    avg
  })
  avg <- do.call('cbind',avgl)
  
  #need to re-prep column annot
  clust_bc <- factor(str_sort(colnames(avg), numeric = T), levels = str_sort(colnames(avg), numeric = T))
  
  col_clust <- setNames(scales::hue_pal()(length(levels(sobjint$seurat_clusters))),
                        nm = levels(sobjint$seurat_clusters))
  
  ha_clust <- ComplexHeatmap::HeatmapAnnotation(Cluster = clust_bc, col = list(Cluster = col_clust))
  
  
  hm_refmarkers_avg <- ComplexHeatmap::Heatmap(avg,
                                               # column_title = 'Integrated clusters',
                                               row_names_gp = grid::gpar(fontsize = 6),
                                               column_names_gp = grid::gpar(fontsize = 6),
                                               column_split = factor(str_sort(colnames(avg), numeric = T), levels = str_sort(colnames(avg), numeric = T)), 
                                               column_title_rot = 0,
                                               column_names_rot = 0, 
                                               
                                               row_split = top$cluster,
                                               row_title_gp = grid::gpar(fontsize = 6),
                                               row_gap = unit(0.5, "mm"), 
                                               column_gap = unit(0.5, "mm"),
                                               row_title_rot = 0,
                                               name = 'Scaled\nExpression',
                                               cluster_columns = F,
                                               cluster_rows = F,
                                               top_annotation = ha_clust,
                                               left_annotation = ha_genes,
                                               use_raster = F)
  
  
  
  
  
  
  #alluvial plot, int clusters to cell type
  labelsdf <- mdint[,c('seurat_clusters', 'top_celltype_thresholded')]
  ap_int_celltypes <- alluvialplot(labelsdf)
  
  
  
  
  
  # cluster-celltype mapping table; still in mem.
  # clustmaxdf
  
  # cluster-celltypr mapped umap
  d5 <- DimPlot(sobjint, group.by = 'INT_celltype_cluster_prediction',
                label = T, repel = T)
  
  
  # vlnplot of score over cluster
  # one plot per condition?
  
  #get celltypes
  ct_ordered <- rownames(hm_ctscores@matrix)[ComplexHeatmap::row_order(hm_ctscores)]
  
  
  #split samples by condition
  
  DefaultAssay(sobjint) <- 'predictions'
  
  
  #make plots of integrated samples
  ctplots_int <- lapply(ct_ordered, function(ct){
    
    
    vct <- VlnPlot(sobjint, ct, pt.size = 0.1)
    
    
    list(vct=vct)
    
    
    
    
  })
  
  names(ctplots_int) <- ct_ordered
  
  DefaultAssay(sobjint) <- 'RISC'
  
  
  
  
  summaryplots_integrated_ct <- list(
    
    hm_ctscores=hm_ctscores,
    dp_ctscores=dp_ctscores,
    
    hm_refmarkers=hm_refmarkers,
    hm_refmarkers_avg=hm_refmarkers_avg,
    
    
    
    d3_int=d3_int,
    d4_int=d4_int,
    ap_int_celltypes=ap_int_celltypes,
    
    clustmaxdf = clustmaxdf,
    d5=d5,
    
    ctplots_int=ctplots_int
    
  )
  
  
  
  
  
  
  pdf( paste0(labeltransfer_outdir_int, '/LabelTransferSummaryPlots.pdf'), height = 9, width=9 )
  
  
  for(i in 1:length(summaryplots_integrated_ct) ){
    
    if(names(summaryplots_integrated_ct)[i] == 'clustmaxdf'){
      print( scDAPP::pdftable(summaryplots_integrated_ct[[i]], title = 'Cluster-Celltype Mapping') )
    } else{
      print(summaryplots_integrated_ct[[i]])
    }
    
  }
  
  dev.off()
  
  
}


```





# Integrated cluster summary plots


```{r summaryplots_int_print_summary, fig.keep='all', message=FALSE, results='asis', fig.height=10, fig.width=10}




plotlab <- "


## UMAP colored by condition

Here we plot a UMAP of the integrated dataset colored according to the sample’s condition. Overall we expect to observe a good overlap, while some sections may be quite distinct. This can correspond to clusters of cell states or cell types that are present in one sample but absent from another.


"

cat( plotlab )


print( summaryplots_integrated$dcond )






plotlab <- "


## UMAP split by condition and colored by sample

Here, the integrated UMAP is split by condition, meaning that cells from Condition A are separated from cells from condition B. Additionally, cells are colored according to their sample origin. This allows us to check the overlap of biological replicates from the same condition.


"

cat( plotlab )


print( summaryplots_integrated$d2_int )






plotlab <- "


## UMAP colored by integrated clusters

Here we plot the same UMAP but this time colored by the integrated clusters. These clusters are important to characterize, as these are the groups that we will compare one-by-one between conditions.


"

cat( plotlab )


print( summaryplots_integrated$d1_int )






plotlab <- "


## UMAP split by condition and colored by integrated clusters

Here we plot the UMAP split by conditon and colored by integrated clusters. This is useful to see compositional differences in which clusters may be enriched or depleted between conditions.


"

cat( plotlab )


print( summaryplots_integrated$dcond_split )




plotlab <- "


## Heatmap of integrated cluster markers

Here we plot the top 5 markers per cluster for the integrated clusters.


"

cat( plotlab )


print( summaryplots_integrated$hm_int )



plotlab <- "


## Averaged heatmap of integrated cluster markers

Here we plot the top 5 markers per cluster for the integrated clusters after averaging over each cluster. It is similar to the marker heatmap above, but can help visualize the cluster-wise expression by plotting the cluster averages instead of each individual cell.


"

cat( plotlab )


print( summaryplots_integrated$hm_int_avg )



plotlab <- "


## Violin Plots of quality metrics

Here we plots some quality metrics for each integrated cluster including number of UMIs per cell (nCount_RNA), number of unique genes detected per cell (nFeature_RNA), percent mitochondrial gene expression (percent.mito), and percent hemoglobin gene expression (percent.hemoglobin).


"

cat( plotlab )


print( summaryplots_integrated$int_qc_vln )





plotlab <- "


## Alluvial plot mapping condition to integrated clusters

This alluvial plot allows us to see the contribution of each condition to each cluster. This allows us to visualize compositional differences between conditions clearly.


"

cat( plotlab )


print( summaryplots_integrated$ap_cond_to_clust )




plotlab <- "


## Alluvial plot mapping samples to integrated clusters

This alluvial plot allows us to see the contribution of each sample to each cluster. Combined with the condition-focused alluvial plot above, this allows us to verify compositional patterns across biological replicates.


"

cat( plotlab )


print( summaryplots_integrated$ap_samp_to_clust )



plotlab <- "


## Per-sample alluvial plots mapping indiviudal sample clusters to integrated clusters

For each sample, we plot an alluvial plot mapping the individual sample clusters with the integrated clusters.


"

cat( plotlab )

indi_int_clust_ap_list <- summaryplots_integrated$indi_int_clust_ap_list



for(i in c(1:length(indi_int_clust_ap_list)) ){
  
  name=names(indi_int_clust_ap_list)[i]
  
  plotlab <- "

### %s

Individual Clusters (left) mapped to Integrated Clusters (right)
  
"
  
  cat(sprintf(plotlab, name))
  
  print(indi_int_clust_ap_list[[i]])
  
}
rm(indi_int_clust_ap_list)


# print( summaryplots_integrated$indi_int_clust_ap_list )


```





```{r labeltransfermessage_3, results='asis'}

if(use_labeltransfer == T){
  
  
  
  text <- '

# Integrated label transfer summary

Above, we explored the integrated clusters. Here, we review the cell type scores from label transfer. The goal is to understand which cell types make up each cluster.

Each cell is a mixture of cells. Using label transfer, we can get a score for each cell type in the tissue. If a cell is composed of one cell type, it will have a high score for that cell type only. If a cell is composed of a mix of cell types, it may have a moderately high score for two or more cell types.

As mentioned above, each cell may contain a single cell or a mixture of cells and potentially multiple cell types. Thus, assigning a single label to each cell is difficult. Nevertheless, we use the label transfer scores to detect patterns of cell types in each cluster.

Note that we apply a label transfer score cutoff of 0.3. If the cells are below this, they are marked as NA. These may represent cells missing from the reference.

'
  
  cat(text)
  
}

```


```{r summaryplots_int_print_celltypes, fig.keep='all', message=FALSE, results='asis', fig.height=10, fig.width=10}


if(use_labeltransfer == T){
  
  
  
  
  plotlab <- "


## Heatmap of cell type label transfer scores with integrated clusters

Here we plot the label transfer scores, which are used to predict cell types from the reference single-cell RNAseq dataset. The values are scaled, allowing easy comparison across clusters.


"
  
  cat( plotlab )
  
  print(summaryplots_integrated_ct$hm_ctscores)
  
  
  
  plotlab <- "


## Dotplot of label transfer cell type scores with integrated clusters

Here we plot the label transfer scores, which are used to predict cell types from the reference single-cell RNAseq dataset. The values are scaled, allowing easy comparison across clusters. It is very similar to the heatmap above. However, the dotplot also includes information about how many cells express the cell type score. A big dot indicates many cells in that cluster express it at non-zero level. A big gray dot indicates widespread, low score among cells. A big red dot indicates widespread, high score among cells. A small dot indicates few cells express the score. 


"
  
  cat( plotlab )
  
  print(summaryplots_integrated_ct$dp_ctscores)
  
  
  
  
  
  
  plotlab <- "


## Heatmap of reference cell type markers in integrated data

Here we plot the top 5 markers of cell types as sorted by average log2 fold change, which  are derived from the reference dataset. Since these are the top specific markers of each cell type in the reference, their expression pattern should match clusters with a high label transfer score for each given cell type, for example a cluster with high T cell score should express high T cell markers.


"
  
  cat( plotlab )
  
  print(summaryplots_integrated_ct$hm_refmarkers)
  
  
  plotlab <- "


## Heatmap of reference cell type markers averaged across clusters

Here we plot the top 5 reference cell type markers by average log2 fold change, this time using the average cluster expression. The markers are derived from the reference dataset. Using averages allows us to easily see which clusters highly or lowly express the reference cell type markers.


"
  
  cat( plotlab )
  
  print(summaryplots_integrated_ct$hm_refmarkers_avg)
  
  
  
  
  
  
  
  
  
  
  plotlab <- "


## UMAP of Top Scoring Celltype

The top scoring celltype is plotted on the UMAP.


"
  
  cat( plotlab )
  
  print(summaryplots_integrated_ct$d3_int)
  
  
  plotlab <- "


## UMAP of label transfer prediction score

The label transfer prediction score is plotted on the UMAP. This is a measure of confidence. Low scoring cells may indicate a new cell in the data that was not present in the reference.


"
  
  cat( plotlab )
  
  print(summaryplots_integrated_ct$d4_int)
  
  
  
  plotlab <- "


## Alluvial plot mapping between Louvain clusters to top celltypes

This alluvial plot maps cluster labels to top celltype labels for each cell. This can be useful to identify general trends of celltype score per cluster.




"
  
  cat( plotlab )
  
  print(summaryplots_integrated_ct$ap_int_celltypes)
  
  
  
  
  plotlab <- '


## Table showing cluster-celltype mapping

We apply an ad-hoc method to extend the label transfer from individual cells (default) across entire clusters. We do this by taking the average score of each cell type score in the cluster and choosing the max. This can help simplify the analysis and can be less noisy by sharing information across cells, but may also hide intra-cluster variability, such as particular sub-clusters which may correspond to distinct cell sub-types.

We also apply a thresholding approach such that clusters with a max score of less than 0.3 are considered non-transferrable and marked as NA (not applicable). These may reflect clusters of cells which are not in the reference dataset.
Additionally, clusters with a score between 0.3 - 0.5 are marked with the suffix "_putative" to indicate the somewhat uncertain status. All cluster markers should be carefully inspected and checked for cell type, independnetly of the label transfer results.

'
  
  cat( plotlab )
  
  clustmaxprint <- summaryplots_integrated_ct$clustmaxdf
  clustmaxprint$score <- round(clustmaxprint$score, digits = 5)
  print(knitr::kable(clustmaxprint))
  
  
  
  plotlab <- "


## UMAP of cluster-celltype mapping

As described above, we extend the label transfer prediction from individual cells to whole clusters in order to denoise and simplify the analysis. Here, rather than plotting the individual cell predictions, we plot the cluster-level predictions.



"
  
  cat( plotlab )
  
  
  print(summaryplots_integrated_ct$d5)
  
  
  
  
  
  #CELLTYPE FEATUREPLOTS
  
  plotlab <- "


## Reference cell types plotted for integrated data for all cell types

Here we plot a summary panel to analyze the label transfer scores for each cell type in detail. To help identify which cluster strongly matches the cell type, the scores are plotted as Violin Plots.


"
  
  cat( plotlab )
  
  
  template_int_celltypes <- "


### %s


"
  
  invisible(
    
    for( i in c(1:length(summaryplots_integrated_ct$ctplots_int)) ){
      
      ct = names(summaryplots_integrated_ct$ctplots_int)[i]
      
      cat(sprintf(template_int_celltypes, ct))
      
      thisct_plots <- summaryplots_integrated_ct$ctplots_int[[i]]
      
      print(thisct_plots$vct)
      
      # invisible(lapply(thisct_plots$ctplots_conds, print))
      
      
      
    }
    
  )
  
  
}

```



# Compositional analysis

Here, we test for differences in the abundance of celltypes (clusters) between conditions. This is referred to as compositional analysis.

If we are comparing two conditions such as treated versus untreated or knockout vs wildtype, one biological effect we can try to test for is the difference in the cell type compositional abundance. The idea that tissue cell type compositions can change in response to biological stimuli has been called "polycreodism" and may reflect particular cell type sensitivity to the perturbation [(Lappalainen & Greally 2017)](https://www.nature.com/articles/nrg.2017.32). For example, it would likely of interest to note that a knockout or drug completely ablates a certain celltype, reduces another by half, increases another by 25%, and leaves others unchanged. Biologically, these kinds of differences can be explained by various mechanisms, such as differentiation of certain cell types being specifically impaired by a knockout, or specific cell types being particularly sensitive to a drug.

We use the scRNA-seq data to test for differential compositional abundance of each cluster. If replicates are present, we make use of these to test differential abdundance across conditions using the "Propeller" method from the R package "speckle" [(Phipson et al 2022)](https://academic.oup.com/bioinformatics/article/38/20/4720/6675456). This method calculates cell proportions for each sample, applies a variance stabilizing transformation, and then compares proportion across conditions via linear regression. It is similar to pseudobulk differential expression analysis in that it takes into accounts having multiple biological replicate samples for each condition. Specifically, we use the arcsin square root transformation by setting "transform = asin". We picked this test and this transformation based on the results of a benchmarking study comparing compositional analysis methods [(Simmons 2022)](https://www.biorxiv.org/content/10.1101/2022.02.04.479123v1.full). Though Propeller calculates False Discovery Rates (FDR), we define significance using only nominal P value for power reasons.

If replicates are not available, we use an ad-hoc method that relies on the R `prop.test()` function, which is very similar to the ChiSquare test (see [this forum discussion](https://stats.stackexchange.com/questions/2391/what-is-the-relationship-between-a-chi-squared-test-and-test-of-equal-proportion)). This works by calculating the proportion of cells in each condition and comparing the proportions. Because there are often thousands of cells being compared, P values can be extremely low. However, this method can result in false-positive conclusions, as the results of 1-vs-1 sample comparisons may not extend to the populations the samples are drawn from. Thus, we advise caution, and interpretation without replicates should be considered as preliminary / pilot data.



``` {r composition_prepanalysis, results='hide', message=FALSE, fig.show='hide', warning=FALSE}



compositional_test <- ifelse(Pseudobulk_mode == T, yes = 'propeller', no = 'chisq' )

comp_result <- compositional_analysis_module(sobjint = sobjint,
                                             comps = comps,
                                             sample_metadata = sample_metadata,
                                             outdir_int = outdir_int,
                                             grouping_variable = 'seurat_clusters',
                                             compositional_test = compositional_test)


composition_comps <- comp_result$composition_comps
globalcomposition <- comp_result$globalcomposition

rm(comp_result)


```



```{r print_compositional,  fig.keep='all', message=FALSE, results='asis', fig.width = 7, fig.height = 7}


plotlab <- '
## Global cell numbers and proportions

Here we show tables of cell numbers and proportions. These can be used to calculate proportion shifts.
'

cat(plotlab)




plotlab <- '
### Table of cell numbers

We display a table of cell numbers for each sample and cluster.
'
cat(plotlab)
cellstab <- as.data.frame.matrix(globalcomposition$cellstab)
cellstab <- cbind(rownames(cellstab), cellstab)
colnames(cellstab)[1] <- 'Cluster'
knitr::kable(cellstab)


plotlab <- '
### Table of cell proportions

We display a table of cell proportions for each sample and cluster. This is calculated by dividing each column by the sample total. We then round to the third digit for display purposes (though the full proportion table is saved in outputs).
'
cat(plotlab)
proptab <- as.data.frame.matrix(globalcomposition$proptab)
printproptab <- round(proptab, 3)
printproptab <- cbind(rownames(printproptab), printproptab)
colnames(printproptab)[1] <- 'Cluster'

knitr::kable(printproptab)

plotlab <- '
### Heatmap of cell proportions in each sample

Here we display a heatmap-style table of cell proportions for each sample and cluster. It is similar to the table above, but we have turned on hierarchical clustering of the rows, to try to visualize patterns of abundance among the clusters.
'
cat(plotlab)
print(globalcomposition$hmprop)



plotlab <- '
## Differential abundance compositional analysis across conditions

Here we summarize differential abundance across conditions as defined in the cross-condition comparisons provided.
'

cat(plotlab)

if(Pseudobulk_mode == T){
  plotlab <- '
Replicates were provided, so we run the propeller test to take into account abundance in each replicate in the cross-condition comparison.
'
} else{
  plotlab <- '
This analysis was run with the prop.test() function in R to compare overall cell proportions between conditions.
'
}

cat(plotlab)



compslen <- 1:nrow(comps)
compidx = 1 #for testing
#prep names
comps$labels <- paste0(comps$c1, '_vs_', comps$c2)

for(compidx in 1:length(compslen) ){
  
  
  #get comparison condition levels
  c1 <- comps[compidx,1]
  c2 <- comps[compidx,2]
  
  #get comp lab
  lab <- comps[compidx,3]
  
  #get comp analysis
  diffcomp <- composition_comps[[lab]]
  
  #get testused
  comptestused <- ifelse(T == T,
                         yes = 'propeller', 
                         no = 'R prop.test()')
  
  
  
  plotlab <- '
### %s
'
  cat(sprintf(plotlab, lab))
  
  
  ## print heatmap
  
  plotlab <- '
#### Heatmap of compositional analysis results

Here we plot a heatmap of the cell proportions and compositional analysis from the %s analysis.

Clusters with significant compositional differences are labelled with two asterisks (ie * 1 *). Significance is defined as P < 0.05.

'
  cat(sprintf(plotlab, comptestused))
  print(diffcomp$hmprop_comp)
  
  
  
  
  ## print table
  
  plotlab <- '

#### Table of compositional analysis results

Here we plot a table of the cell proportions and compositional analysis from the %s analysis. We round to the 3rd digit for display, which can result in low P values being shown as zeros (though the full analysis is saved in the output folder).

Clusters with significant compositional differences are labelled with two asterisks (ie * 1 *). Significance is defined as P < 0.05. FDR is not used to define significance but is provided for convenience.

'
  
  cat(sprintf(plotlab, comptestused))
  print_compres <- diffcomp$compres
  print_compres[,-1] <- round(print_compres[,-1], 3)
  print(knitr::kable(print_compres))
  
}




### clean up env
rm(print_compres, diffcomp, composition_comps, globalcomposition)
invisible(gc(full = T, reset = F, verbose = F))

```



# Differential expression across conditions


Below we summarize the results of cross-condition differential expression (DE) analysis, for example KO vs WT, or disease vs healthy, or drugged vs control. As in single-cell data, we stratify the cross-condition DE by cluster. In other words, using the clusters defined above, we compare KO vs WT in cluster 1, cluster 2, and so on. For these types of analysis, it is recommended to have multiple biological replicates per condition.

If multiple replicates are available, then the best way to take advantage of these is to use a "pseudobulk" strategy. This refers to an approach in which cells from each sample are pooled together, and bulk RNA-seq analysis methods are used to identify DE genes across conditions. Pseudobulk differential expression analysis is done with EdgeR likelihood ratio test, as recommended by [Squair et al 2021 Nat Com.](https://www.nature.com/articles/s41467-021-25960-2)

If replicates are not available, it is still possible to compare conditions. This is done using a wilcoxon test approach. Drawing conclusions from the results of this type of analysis are inherently limited as they constitute "N of 1" experiments, but can be considered as preliminary/pilot data.


```{r de_test_used_text, results='asis'}


if(Pseudobulk_mode == T){
  
  detestused_text <- 'The differential expression analysis here used a pseudobulk edgeR approach. First, cells are "pseudobulked", or combined,  at the cluster level by adding up the gene UMI counts in all cells in each cluster for each replicate. Next, EdgeR with the likelihood ratio test is applied.'
  
}
if(Pseudobulk_mode == F){
  
  detestused_text <- 'The differential expression analysis here used a non-pseudobulk Wilcoxon test approach. The normalized counts of each gene are compared between cells in condition A vs B in each cluster.'
  
}


cat(detestused_text)


```



``` {r de_across_conditions, results='hide', message=FALSE, fig.show='hide', warning=FALSE}



#prep names
comps$labels <- paste0(comps$c1, '_vs_', comps$c2)

#read sobjlist back in? keep it in?
# will need to optimize memory

#get cluster object name
clustname <- risc_clust_lab


if(Pseudobulk_mode == T){
  
  m_bycluster_crosscondition_de_comps <- de_across_conditions_module(
    sobjint = sobjint,
    sample_metadata = sample_metadata,
    comps = comps,
    grouping_variable = clustname,
    outdir_int=outdir_int,
    assay = 'RNA', slot = 'counts',
    Pseudobulk_mode = T,
    cluster_prefix = T,
    crossconditionDE_padj_thres = crossconditionDE_padj_thres,
    crossconditionDE_lfc_thres = crossconditionDE_lfc_thres,
    crossconditionDE_min.pct = 0.1
  )
  
} else{
  
  m_bycluster_crosscondition_de_comps <- de_across_conditions_module(
    sobjint = sobjint,
    sample_metadata = sample_metadata,
    comps = comps,
    grouping_variable = clustname,
    outdir_int=outdir_int,
    assay = 'RISC', slot = 'data',
    Pseudobulk_mode = F,
    cluster_prefix = T,
    crossconditionDE_padj_thres = crossconditionDE_padj_thres,
    crossconditionDE_lfc_thres = crossconditionDE_lfc_thres,
    crossconditionDE_min.pct = 0
  )
  
}



```




``` {r de_prepplots, results='hide', message=FALSE, fig.show='hide', warning=FALSE}




compslen <- 1:nrow(comps)
compidx = 1 #for testing


outdir_DE <- paste0(outdir_int, '/differentialexpression_crosscondition/')
outdir_DE_plots <- paste0(outdir_DE, '/plots/')
dir.create(outdir_DE_plots, recursive = T)


DEplots_comps <- lapply(compslen, function(compidx){
  
  
  #get comparison condition levels
  c1 <- comps[compidx,1]
  c2 <- comps[compidx,2]
  
  #get comp lab
  lab <- comps[compidx,3]
  
  message(lab)
  
  #get cross conditions res per cluster list
  m_bycluster_crosscondition_de <- m_bycluster_crosscondition_de_comps[[compidx]]
  
  
  #get num DEGs
  crossconditionDE_min.pct <- ifelse(Pseudobulk_mode == T, yes = 0.1, no = 0)
  numdegs <- sapply(m_bycluster_crosscondition_de, function(m){
    
    #normal fdr and padj thresholds
    m <- m[m$FDR < crossconditionDE_padj_thres,, drop=F]
    m <- m[abs(m$logFC) > crossconditionDE_lfc_thres,, drop=F]
    
    #pct thresholds: +FC, pct1 > 0.1; -FC, pct2 > 0.1
    
    upm <- m[m$logFC > 0,,drop=F]
    upm <- upm[upm$pct.1 > crossconditionDE_min.pct,, drop=F]
    
    dnm <- m[m$logFC < 0,,drop=F]
    dnm <- dnm[dnm$pct.2 > crossconditionDE_min.pct,, drop=F]
    
    m <- rbind(upm,dnm)
    
    try( table( factor(sign(m$logFC), levels=c(-1,1)) ) )
  })
  
  numdegs <- t(numdegs)
  colnames(numdegs) <- c(c2, c1)
  
  #make sure all clusters are shown
  # make a fake df and replace fake with real res
  saved_cluster_levels <- paste0('cluster_',levels(sobjint$seurat_clusters))
  numdegs_all <- data.frame(Cluster = saved_cluster_levels,
                            c1 = 0, c2 = 0)
  colnames(numdegs_all) <- c('Cluster', c1, c2)
  rownames(numdegs_all) <- numdegs_all$Cluster
  
  numdegs_all[rownames(numdegs), c1] <- numdegs[,c1]
  numdegs_all[rownames(numdegs), c2] <- numdegs[,c2]
  rownames(numdegs_all) <- NULL
  
  
  
  ### at least one DEG must be present ###
  numdegs <- numdegs[ (numdegs[,1] > 0) | (numdegs[,2] > 0) , ] 
  
  
  #make sure all samples from pmd are in the mlist...
  subpmd <- sample_metadata[sample_metadata$Condition %in% c(c1,c2),]
  
  #for each cluster, get the up/dn DEGs
  i = 3
  clustres <- lapply(1:nrow(numdegs), function(i){
    
    clustlab <- rownames(numdegs)[i]
    m <- m_bycluster_crosscondition_de[[clustlab]]
    
    m <- m[m$FDR < crossconditionDE_padj_thres,, drop=F]
    m <- m[abs(m$logFC) > crossconditionDE_lfc_thres,, drop=F]
    
    crossconditionDE_min.pct <- ifelse(Pseudobulk_mode == T, yes = 0.1, no = 0)
    
    upm <- m[m$logFC > 0,,drop=F]
    upm <- upm[upm$pct.1 > crossconditionDE_min.pct,, drop=F]
    
    dnm <- m[m$logFC < 0,,drop=F]
    dnm <- dnm[dnm$pct.2 > crossconditionDE_min.pct,, drop=F]
    
    m <- rbind(upm,dnm)
    
    
    #make sure all samples are in top
    # only if de pseudobulk
    if(Pseudobulk_mode == T){
      
      if( any(!(subpmd$Code %in% colnames(m))) ){
        missingcodes <- subpmd$Code[!(subpmd$Code %in% colnames(m))]
        missingcodecols <- lapply(missingcodes, function(code){
          missingdf <- data.frame(missing = rep(0, nrow(m)) )
          colnames(missingdf) <- code
          return(missingdf)
        })
        
        missingcodecols <- dplyr::bind_cols(missingcodecols)
        
        
        
        #bind missing cols to results
        m <- cbind(m,missingcodecols)
        
      }
      
      #make sure order of samples is consistent
      m_nosamp <- m[,!(colnames(m) %in% subpmd$Code)]
      msamp <- m[,colnames(m) %in% subpmd$Code,drop=F]
      msamp <- msamp[, match(subpmd$Code, colnames(msamp)) ]
      
      m <- cbind(m_nosamp, msamp)
      
      
      
    }
    
    
    m$cluster <- clustlab
    
    return(m)
    
  })
  
  names(clustres) <- rownames(numdegs)
  
  # clustres <- do.call(rbind, clustres)
  
  
  
  
  
  
  
  
  
  
  
  # ### summary heatmap ###
  # 
  # # first make a summary heatmap, top 3 DEGs from each cluster up/dn...
  # 
  # top <- lapply(clustres, function(m){
  #   top <- head( m[m$logFC > 0,,drop=F] , n = 3 ) 
  #   btm <- tail( m[m$logFC < 0,,drop=F] , n = 3 )
  #   
  #   subm <- rbind(top,btm)
  #   
  #   return(subm)
  # })
  # 
  # top <- do.call(rbind, top)
  # rownames( top ) <- NULL
  # 
  # 
  # #to make things easier, remove "cluster_"
  # top$cluster <- gsub('cluster_', '', top$cluster)
  # 
  # 
  # 
  # genes <- top$gene_symbol
  # 
  # 
  # #subset for just these conditions
  # md <- sobjint@meta.data
  # md <- md[md$Condition %in% c(c1,c2),]
  # sobjsub <- sobjint[,rownames(md)]
  # 
  # #scale the relevant genes
  # # sobjsub <- ScaleData(sobjsub, features = genes, verbose = verbose)
  # 
  # 
  # # get the gene matrix
  # # gem <- sobjsub@assays$RISC@scale.data
  # gem <- sobjsub@assays$RISC@data
  # 
  # 
  # #prep heatmap
  # top <- top[top$gene %in% rownames(sobjsub),]
  # gem <- gem[match(genes, rownames(gem)),]
  # 
  # #as matrix
  # gem <- as.matrix(gem)
  # 
  # 
  # #annot for clusters
  # 
  # 
  # #first order gem by cluster...
  # md <- sobjsub@meta.data
  # md <- md[order(md$seurat_clusters),]
  # 
  # #within cluster, order by condition...
  # mdx <- lapply( unique(md$seurat_clusters) , function(clust){
  #   mdsub <- md[md$seurat_clusters==clust,]
  #   
  #   mdc1 <- mdsub[mdsub$Condition == c1,,drop=F]
  #   mdc2 <- mdsub[mdsub$Condition == c2,,drop=F]
  #   
  #   mdsub <- rbind(mdc1,mdc2)
  #   return(mdsub)
  #   
  # })
  # md <- do.call(rbind, mdx)
  # 
  # #match gem order too
  # gem <- gem[,match(rownames(md), colnames(gem))]
  # 
  # #cluster annot and colors
  # clust_bc <- setNames(md$seurat_clusters,
  #                      nm = colnames(gem)
  # )
  # col_clust <- setNames(scales::hue_pal()(length(levels(sobjsub$seurat_clusters))),
  #                       nm = levels(sobjsub$seurat_clusters))
  # 
  # #condition annot and colors
  # cond_bc <- setNames(md$Condition,
  #                     nm = colnames(gem))
  # 
  # #for cond colors, set up color scheme...
  # set2 <- c("#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854", "#FFD92F", "#E5C494", "#B3B3B3")
  # 
  # 
  # set2 <- set2[1:length(unique(sample_metadata$Condition))]
  # 
  # col_cond <- setNames(set2,
  #                      nm = unique(sample_metadata$Condition) )
  # 
  # col_cond <- col_cond[names(col_cond) %in% c(c1,c2)]
  # 
  # 
  # 
  # ha_clust <- ComplexHeatmap::HeatmapAnnotation(Cluster = clust_bc, 
  #                                               Condition = cond_bc,
  #                                               
  #                                               col = list(Cluster = col_clust,
  #                                                          Condition = col_cond),
  #                                               show_legend = F)
  # 
  # 
  # 
  # #annot for markers
  # #set genes according to ct_ordered
  # top$cluster <- factor(top$cluster, levels=unique(top$cluster))
  # 
  # #condition; can just use +/- lfc
  # top$Condition <- c1
  # top[top$logFC < 0, 'Condition'] <- c2
  # 
  # 
  # #match order of genes of gem with stats res
  # gem <- gem[match(top$gene, rownames(gem)),]
  # 
  # 
  # #set up annot for cluster for genes
  # ct_gene <- setNames(top$cluster,
  #                     nm=top$gene_symbol)
  # col_gene <- col_clust
  # # col_gene <- col_gene[names(col_gene) %in% top$cluster]
  # 
  # #set up annot for condition for genes
  # cond_gene <- setNames(top$Condition,
  #                       nm = top$gene_symbol)
  # col_genecond <- col_cond
  # 
  # 
  # ha_genes <- ComplexHeatmap::rowAnnotation(Cluster = ct_gene,
  #                                           Condition = cond_gene,
  #                                           col = list(Cluster = col_gene, Condition = col_genecond),
  #                                           show_annotation_name=F)
  # 
  # 
  # #restrict range
  # # gem[gem>5] <- 5
  # # gem[gem<-5] <- -5
  # gem <- log1p(gem)
  # 
  # pal <- circlize::colorRamp2(c(0,  max(gem)), c("white", "red"))
  # 
  # #actual heatmap
  # hm_DE <- ComplexHeatmap::Heatmap(gem,
  #                                  # column_title = 'Integrated clusters',
  #                                  column_labels = rep('', ncol(gem)),
  #                                  row_names_gp = grid::gpar(fontsize = 5),
  #                                  column_split = md$seurat_clusters,
  #                                  row_split = top$cluster,
  #                                  row_title_gp = grid::gpar(fontsize = 5),
  #                                  row_gap = unit(0.8, "mm"), 
  #                                  column_gap = unit(0.8, "mm"),
  #                                  border_gp = gpar(col = "black", lwd = 0.1),
  #                                  row_title_rot = 0,
  #                                  column_title_rot = 45,
  #                                  column_title_gp = grid::gpar(fontsize = 7), 
  #                                  col = pal,
  #                                  name = 'Log1p\nRISC Norm\nCounts',
  #                                  cluster_columns = F,
  #                                  cluster_rows = F,
  #                                  top_annotation = ha_clust,
  #                                  left_annotation = ha_genes,
  #                                  use_raster = F)
  # 
  # 
  # 
  # 
  # 
  # 
  # 
  # 
  # 
  # ### same thing but avg
  # # ie, avg clust 1 c1, avg clust 1 c2, avg clust 2 c1, avg clust 2 c2, etc...
  # 
  # 
  # md <- sobjsub@meta.data
  # md$condclust <- paste0( md$seurat_clusters, '_c1')
  # md[md$Condition == c2,'condclust'] <- paste0( md[md$Condition == c2,'seurat_clusters'], '_c2')
  # oldlevs <- str_sort(unique(md$condclust), numeric = T)
  # levs <- oldlevs
  # levs <- gsub('c1', c1, levs)
  # levs <- gsub('c2', c2, levs)
  # md$condclust <- factor(md$condclust, levels = oldlevs)
  # md$condclust <- plyr::mapvalues(md$condclust, oldlevs, levs)
  # 
  # 
  # sobjsub$condclust <- md$condclust
  # avg <- AverageExpression(sobjsub, assays = 'RISC', slot = 'data', 
  #                          features = rownames(gem),
  #                          group.by = 'condclust')
  # 
  # 
  # avg <- as.matrix(avg[[1]])
  # 
  # ## set up avg heatmap, annots etc ##
  # 
  # #column annots
  # #cluster annot and colors
  # AVGclust_bc <- setNames(str_split_fixed(colnames(avg), '_', 2)[,1],
  #                         nm = colnames(avg)
  # )
  # AVGcol_clust <- setNames(scales::hue_pal()(length(levels(sobjsub$seurat_clusters))),
  #                          nm = levels(sobjsub$seurat_clusters))
  # 
  # #condition annot and colors
  # AVGcond_bc <- setNames(str_split_fixed(colnames(avg), '_', 2)[,2],
  #                        nm = colnames(avg))
  # 
  # #for cond colors, set up color scheme...
  # set2 <- c("#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854", "#FFD92F", "#E5C494", "#B3B3B3")
  # 
  # set2 <- set2[1:length(unique(sample_metadata$Condition))]
  # 
  # col_cond <- setNames(set2,
  #                      nm = unique(sample_metadata$Condition) )
  # 
  # col_cond <- col_cond[names(col_cond) %in% c(c1,c2)]
  # 
  # 
  # 
  # ha_clust <- ComplexHeatmap::HeatmapAnnotation(Cluster = AVGclust_bc, 
  #                                               Condition = AVGcond_bc,
  #                                               
  #                                               col = list(Cluster = AVGcol_clust,
  #                                                          Condition = col_cond),
  #                                               show_legend = F)
  # 
  # 
  # 
  # 
  # #annot for markers
  # #set genes according to ct_ordered
  # # top$cluster <- factor(top$cluster, levels=unique(top$cluster))
  # 
  # #condition; can just use +/- lfc
  # # top$Condition <- c1
  # # top[top$logFC < 0, 'Condition'] <- c2
  # 
  # 
  # #match order of genes of gem with stats res
  # avg <- avg[match(top$gene, rownames(avg)),]
  # 
  # 
  # # #set up annot for cluster for genes
  # # ct_gene <- setNames(top$cluster,
  # #                     nm=top$gene_symbol)
  # # col_gene <- col_clust
  # # # col_gene <- col_gene[names(col_gene) %in% top$cluster]
  # # 
  # # #set up annot for condition for genes
  # # cond_gene <- setNames(top$Condition,
  # #                       nm = top$gene_symbol)
  # # col_genecond <- col_cond
  # # 
  # # 
  # # ha_genes <- ComplexHeatmap::rowAnnotation(Cluster = ct_gene,
  # #                                           Condition = cond_gene,
  # #                                           col = list(Cluster = col_gene, Condition = col_genecond),
  # #                                           show_annotation_name=F)
  # 
  # 
  # #restrict range
  # # gem[gem>5] <- 5
  # # gem[gem<-5] <- -5
  # 
  # avg <- log1p(avg)
  # 
  # pal <- circlize::colorRamp2(c(0,  max(avg)), c("white", "red"))
  # 
  # #make column order not alphabetic...
  # colsplit <- colnames(avg)
  # colsplit <- as.character(colsplit)
  # colsplit <- str_split_fixed(colsplit, '_', 2)[,1]
  # colsplit <- factor( colsplit,
  #                     levels = str_sort(unique(colsplit), numeric = T))
  # 
  # #actual heatmap
  # hm_DE_AVG <- ComplexHeatmap::Heatmap(avg,
  #                                      # column_title = 'Integrated clusters',
  #                                      # column_labels = rep('', ncol(gem)),
  #                                      column_names_gp = grid::gpar(fontsize = 5),
  #                                      column_names_rot = 45,
  #                                      row_names_gp = grid::gpar(fontsize = 5),
  #                                      column_split = colsplit,
  #                                      row_split = top$cluster,
  #                                      row_title_gp = grid::gpar(fontsize = 5),
  #                                      row_gap = unit(0.8, "mm"), 
  #                                      column_gap = unit(0.8, "mm"),
  #                                      border_gp = gpar(col = "black", lwd = 0.1),
  #                                      row_title_rot = 0,
  #                                      column_title_rot = 45,
  #                                      column_title_gp = grid::gpar(fontsize = 7), 
  #                                      col = pal,
  #                                      name = 'Log1p\nRISC Norm\nCounts',
  #                                      cluster_columns = F,
  #                                      cluster_rows = F,
  #                                      top_annotation = ha_clust,
  #                                      left_annotation = ha_genes,
  #                                      use_raster = F)
  # 
  # 
  # 
  # 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  ### for each cluster, make a heatmap of the DEGs using single-cell data
  i=3
  cluster_de_heatmap_l <- lapply(1:length(clustres), function(i){
    
    
    #get DEGs
    m <- clustres[[i]]
    
    #sort degs
    m <- m[order(m$logFC, decreasing = T),]
    
    #get cluster name
    cluster <- names(clustres)[i]
    
    message(cluster)
    
    #get cluster without "cluster_" prefix
    cluster_noprefix <- gsub('cluster_', '', cluster)
    
    #get cluster cells; order by c1 then c2
    md <- sobjint@meta.data
    mdclust <- md[md$seurat_clusters == cluster_noprefix,]
    mdclust <- mdclust[mdclust$Condition %in% c(c1,c2),]
    mdclust$Condition <- factor(mdclust$Condition, levels = c(c1,c2))
    mdclust <- mdclust[order(mdclust$Condition), ]
    
    clustcells <- rownames(mdclust)
    
    #get matrix of DEGs of cells from this cluster
    mat <- sobjint@assays$RISC@data
    mat <- mat[match(m$gene_symbol, rownames(mat)),clustcells,drop=F]
    
    
    #scale matrix
    mat <- as.matrix(mat)
    mat <- t(scale(t(mat)))
    
    #restrict range
    mat[mat > 5 ] <- 5
    mat[mat < -5] <- -5
    
    hm_de_clust <- Heatmap(mat, 
                           show_column_names = F, 
                           cluster_column_slices = F, cluster_columns = F,
                           cluster_row_slices = F, cluster_rows = F,
                           show_row_names = ifelse(nrow(mat)<=50, yes = T, no = F), 
                           name = paste0('Scaled\nRISC\nValues'), 
                           column_split = mdclust$Condition, 
                           row_split = factor(sign(m$logFC), levels = c(1,-1)),
                           border_gp = gpar(col = "black", lwd = 1)
                           
    )
    
    pdf(NULL)
    hm_de_clust <- invisible(
      draw(hm_de_clust, 
           column_title = paste0(lab, '\n', str_to_title(cluster) ),
           row_title = 'Log Fold Change Sign')
    )
    dev.off()
    
    
    
    if(Pseudobulk_mode == T){
      ### just plot the values
      pb_mat <- m[,colnames(m) %in% mdclust$Code]
      
      
      
      pb_mat <- as.matrix(pb_mat)
      pb_mat <- log1p(pb_mat)
      pb_mat <- t(scale(t(pb_mat)))
      
      #restrict range
      pb_mat[pb_mat > 5 ] <- 5
      pb_mat[pb_mat < -5] <- -5
      
      
      #order md properly
      #get just this comp samples
      subpmd <- sample_metadata[sample_metadata$Condition %in% c(c1,c2),]
      
      
      
      #order columns of heatmap by c1 vs c2
      code_comps_order <- subpmd[subpmd$Condition == c1,"Code"]
      code_comps_order <- c(code_comps_order, subpmd[subpmd$Condition == c2,"Code"])
      
      #make sure they are in the matrix
      code_comps_order <- code_comps_order[code_comps_order %in% colnames(pb_mat)]
      
      #also prepare factor for ordering of heatmap
      condition_vector_ordering <- factor(subpmd[match(code_comps_order, subpmd$Code), "Condition"], levels = c(c1,c2))
      
      
      pb_mat <- pb_mat[,code_comps_order,drop=F]
      
      
      hm_de_clust_pb <- Heatmap(pb_mat, 
                                show_column_names = T, 
                                cluster_column_slices = F, cluster_columns = F,
                                cluster_row_slices = F, cluster_rows = F,
                                show_row_names = ifelse(nrow(mat)<=50, yes = T, no = F), 
                                name = paste0('Scaled\nPseudobulk\nValues'),
                                column_split = condition_vector_ordering, 
                                row_split = factor(sign(m$logFC), levels = c(1,-1)),
                                border_gp = gpar(col = "black", lwd = 1)
      )
      
      
      pdf(NULL)
      hm_de_clust_pb <- invisible(
        draw(hm_de_clust_pb, 
             column_title = paste0(lab, '\n', str_to_title(cluster) ),
             row_title = 'Log Fold Change Sign')
      )
      dev.off()
      
      
    }
    
    if(Pseudobulk_mode == F){
      
      #get DEGs
      m <- clustres[[i]]
      
      #sort degs
      m <- m[order(m$logFC, decreasing = T),]
      
      #get cluster name
      cluster <- names(clustres)[i]
      
      #get cluster without "cluster_" prefix
      cluster_noprefix <- gsub('cluster_', '', cluster)
      
      #get cluster cells; order by c1 then c2
      md <- sobjint@meta.data
      mdclust <- md[md$seurat_clusters == cluster_noprefix,]
      mdclust$Condition <- factor(mdclust$Condition, levels = c(c1,c2))
      mdclust <- mdclust[order(mdclust$Condition), ]
      
      clustcells <- rownames(mdclust)
      
      #get matrix of DEGs of cells from this cluster
      mat <- sobjint@assays$RISC@data
      mat <- mat[match(m$gene_symbol, rownames(mat)),clustcells,drop=F]
      
      #order md properly
      #get just this comp samples
      subpmd <- sample_metadata[sample_metadata$Condition %in% c(c1,c2),]
      
      #order columns of heatmap by c1 vs c2
      code_comps_order <- subpmd[subpmd$Condition == c1,"Code"]
      code_comps_order <- c(code_comps_order, subpmd[subpmd$Condition == c2,"Code"])
      
      #make sure sample is even present in cluster
      code_comps_order <- code_comps_order[code_comps_order %in% mdclust$Code]
      
      #also prepare factor for ordering of heatmap
      condition_vector_ordering <- factor(subpmd[match(code_comps_order, subpmd$Code), "Condition"], levels = c(c1,c2))
      
      
      avg_l <- lapply(code_comps_order, function(code){
        codecells <- rownames(mdclust[mdclust$Code == code,])
        avgmat <- Matrix::rowMeans(mat[,codecells, drop=F])
        
        avgmat <- matrix(avgmat)
        rownames(avgmat) <- rownames(mat); colnames(avgmat) <- code
        return(avgmat)
      })
      avgmat <- as.matrix(dplyr::bind_cols(avg_l))
      rownames(avgmat) <- rownames(mat)
      colnames(avgmat) <- code_comps_order
      
      avgmat <- as.matrix(avgmat)
      avgmat <- t(scale(t(avgmat)))
      
      #restrict range
      avgmat[avgmat > 5 ] <- 5
      avgmat[avgmat < -5] <- -5
      
      hm_de_clust_pb <- Heatmap(avgmat, 
                                show_column_names = T, 
                                cluster_column_slices = F, cluster_columns = F,
                                cluster_row_slices = F, cluster_rows = F,
                                show_row_names = ifelse(nrow(mat)<=50, yes = T, no = F), 
                                name = paste0('Scaled\nMean\nRisc\nValues'),
                                column_split = condition_vector_ordering, 
                                row_split = factor(sign(m$logFC), levels = c(1,-1)),
                                border_gp = gpar(col = "black", lwd = 1)
      )
      
      
      pdf(NULL)
      hm_de_clust_pb <- invisible(
        draw(hm_de_clust_pb, 
             column_title = paste0(lab, '\n', str_to_title(cluster) ),
             row_title = 'Log Fold Change Sign')
      )
      dev.off()
      
      
      
      
    }
    
    
    return(list(hm_de_clust = hm_de_clust,
                hm_de_clust_pb = hm_de_clust_pb))
    
  })
  
  
  
  names(cluster_de_heatmap_l) <- names(clustres)
  
  
  deplotlist <- list(#hm_DE = hm_DE,
    #hm_DE_AVG = hm_DE_AVG,
    cluster_de_heatmap_l = cluster_de_heatmap_l)
  
  
  
  
  deplotfile <- paste0(outdir_DE_plots, lab, '.pdf')
  
  pdf(deplotfile, height = 9, width = 9)
  
  # print(deplotlist$hm_DE)
  # print(deplotlist$hm_DE_AVG)
  invisible(print(deplotlist$cluster_de_heatmap_l))
  
  dev.off()
  
  return(deplotlist)
  
  
  
})




names(DEplots_comps) <- comps$labels


```





``` {r pathwayanalysis_crosscondition, results='hide', message=FALSE, fig.show='hide', warning=FALSE }



### save cluster levels ###
saved_cluster_levels <- levels(sobjint$seurat_clusters)

pwayoutdir <- paste0(outdir_int, '/pathwayanalysis_crosscondition/')
dir.create(pwayoutdir, recursive = T)

#at this point, we no longer need many of the high memory using objects
rm(sobjint, 
   ap_cond_to_clust, ap_int_celltypes, ap_samp_to_clust, avg, avgl, ctplots_int,
   cutoffplots, cutoffs,d1_int, d2_int, d3_int,dcond,dcond_split,dend,dp_ctscores,
   gem,ha_clust,ha_genes,hm_ctscores,hm_int, hm_refmarkers, hm_refmarkers_avg,
   intmd, labelsdf, m_integrated_clusters,m_ref_small, m_reference, md,mdint,nicedend,
   sampsumplots, summaryplots_integrated, summaryplots_integrated_ct, thisct_plots, top,
   d4_int, ip)

invisible(gc(full = T, reset = F, verbose = F))


#prep pathways
pathways <- preppathways_pathwayanalysis_crosscondition_module(species = species,
                                                               outdir_int = outdir_int)

### run main pathway analysis ###
pways_output_list <- pathwayanalysis_crosscondition_module(
  m_bycluster_crosscondition_de_comps = m_bycluster_crosscondition_de_comps,
  pathways = pathways,
  sample_metadata = sample_metadata,
  # deg.weight = "pval", #this is deprecated now
  comps = comps,
  workernum = workernum,
  outdir_int = outdir_int
)


pathway_analysis_mainlist_comps <- pways_output_list$pathway_analysis_mainlist_comps
pathwaysummplots_comps <- pways_output_list$pathwaysummplots_comps



### for easily reproducing plots and etc, save them as R objects...

DE_pathways_plot_objects_list <- list(comps = comps,
                                      m_bycluster_crosscondition_de_comps = m_bycluster_crosscondition_de_comps,
                                      pathway_analysis_mainlist_comps = pathway_analysis_mainlist_comps,
                                      pathwaysummplots_comps = pathwaysummplots_comps,
                                      crossconditionDE_padj_thres = crossconditionDE_padj_thres,
                                      crossconditionDE_lfc_thres = crossconditionDE_lfc_thres)




DE_pathways_plot_objects_list_file <- paste0(pwayoutdir, '/DE_pathways_plot_objects_list.rds')

saveRDS(DE_pathways_plot_objects_list, DE_pathways_plot_objects_list_file)



```



```{r print_pwayanalysis_to_html,  fig.keep='all', message=FALSE, results='asis', fig.width = 7, fig.height = 9}




#### print out NUMDEGS, NUMDEGS THRESHOLDED, AND PWAY ANALYSIS TO HTML


#do this for each comparison


compslen <- nrow(comps)

for(compidx in c(1:compslen) ){
  
  
  #get comparison condition levels
  c1 <- comps[compidx,1]
  c2 <- comps[compidx,2]
  
  #get comp lab
  lab <- comps[compidx,3]
  
  #get cross conditions res per cluster list
  m_bycluster_crosscondition_de <- m_bycluster_crosscondition_de_comps[[compidx]]
  
  #get pway results full list
  pathway_analysis_mainlist <- pathway_analysis_mainlist_comps[[compidx]]
  
  #get pway summary plots
  summplots_cats <- pathwaysummplots_comps[[compidx]]
  
  
  
  # get the deplots
  deplotlist <- DEplots_comps[[lab]]
  
  
  complab <- "


## %s


"
  
  cat(sprintf(complab, lab))
  
  
  
  
  
  if(Pseudobulk_mode == T){
    
    plotlab <- "


### Number of significant DEGs across conditions in each cluster

Here we check number of differentially expressed genes (DEGs) after applying some statistical thresholds:
    
* Adjusted P value < %s

* Log Fold Change > +/- %s

* Proportion of cells expressing gene in condition A > 0.1 if LFC is positive

* Proportion of cells expressing gene in condition B > 0.1 if LFC is negative

Differential expression compares genes in condition A (left) versus condition B (right). The left column indicates the number of genes upregulated in the left condition, while the right column indicates genes upregulated in the right condition.

Finally, the thresholds above do not affect downstream results from pathway analysis, they are just meant to count the number of DEGs. Downstream usage of DEGs can use these thresholds, or you can choose other appropriate cutoffs.

"
    
    cat( sprintf(plotlab, crossconditionDE_padj_thres, crossconditionDE_lfc_thres) )
    
    
    numdegs <- sapply(m_bycluster_crosscondition_de, function(m){
      
      #normal fdr and padj thresholds
      m <- m[m$FDR < crossconditionDE_padj_thres,, drop=F]
      m <- m[abs(m$logFC) > crossconditionDE_lfc_thres,, drop=F]
      
      #pct thresholds: +FC, pct1 > 0.1; -FC, pct2 > 0.1
      
      upm <- m[m$logFC > 0,,drop=F]
      upm <- upm[upm$pct.1 > 0.1,, drop=F]
      
      dnm <- m[m$logFC < 0,,drop=F]
      dnm <- dnm[dnm$pct.2 > 0.1,, drop=F]
      
      m <- rbind(upm,dnm)
      
      try( table( factor(sign(m$logFC), levels=c(-1,1)) ) )
    })
    
    numdegs <- t(numdegs)
    colnames(numdegs) <- c(c2, c1)
    
    #make sure all clusters are shown
    # make a fake df and replace fake with real res
    saved_cluster_levels_withlab <- paste0('cluster_', saved_cluster_levels)
    numdegs_all <- data.frame(Cluster = saved_cluster_levels_withlab,
                              c1 = 0, c2 = 0)
    colnames(numdegs_all) <- c('Cluster', c1, c2)
    rownames(numdegs_all) <- numdegs_all$Cluster
    
    numdegs_all[rownames(numdegs), c1] <- numdegs[,c1]
    numdegs_all[rownames(numdegs), c2] <- numdegs[,c2]
    rownames(numdegs_all) <- NULL
    
    #rename colnames to have high
    colnames(numdegs_all) <- c('Cluster', paste0(c1, '_high'), paste0(c2, '_high'))
    
    print(knitr::kable(numdegs_all))
    
  }
  
  if(Pseudobulk_mode == F){
    
    
    plotlab <- "


### Number of significant DEGs across conditions in each cluster

Here we check number of differentially expressed genes (DEGs) after applying some statistical thresholds:
    
* Adjusted P value < %s

* Log Fold Change > +/- %s

Differential expression compares genes in condition A (left) versus condition B (right). The left column indicates the number of genes upregulated in the left condition, while the right column indicates genes upregulated in the right condition.

Finally, the thresholds above do not affect downstream results from pathway analysis, they are just meant to count the number of DEGs. Downstream usage of DEGs can use these thresholds, or you can choose other appropriate cutoffs.

"
    
    cat( sprintf(plotlab, crossconditionDE_padj_thres, crossconditionDE_lfc_thres) )
    
    
    
    numdegs <- sapply(m_bycluster_crosscondition_de, function(m){
      
      #normal fdr and padj thresholds
      m <- m[m$FDR < crossconditionDE_padj_thres,, drop=F]
      m <- m[abs(m$logFC) > crossconditionDE_lfc_thres,, drop=F]
      
      #pct thresholds for pb_edgeR only: +FC, pct1 > 0.1; -FC, pct2 > 0.1
      
      upm <- m[m$logFC > 0,,drop=F]
      
      dnm <- m[m$logFC < 0,,drop=F]
      
      m <- rbind(upm,dnm)
      
      try( table( factor(sign(m$logFC), levels=c(-1,1)) ) )
    })
    
    numdegs <- t(numdegs)
    colnames(numdegs) <- c(c2, c1)
    
    #make sure all clusters are shown
    # make a fake df and replace fake with real res
    saved_cluster_levels_withlab <- paste0('cluster_', saved_cluster_levels)
    numdegs_all <- data.frame(Cluster = saved_cluster_levels_withlab,
                              c1 = 0, c2 = 0)
    colnames(numdegs_all) <- c('Cluster', c1, c2)
    rownames(numdegs_all) <- numdegs_all$Cluster
    
    numdegs_all[rownames(numdegs), c1] <- numdegs[,c1]
    numdegs_all[rownames(numdegs), c2] <- numdegs[,c2]
    rownames(numdegs_all) <- NULL
    
    #rename colnames to have high
    colnames(numdegs_all) <- c('Cluster', paste0(c1, '_high'), paste0(c2, '_high'))
    
    print(knitr::kable(numdegs_all))
    
    
    
    
  }
  
  
  
  
  
  #   plotlab <- '
  # ### Heatmap of top cross-condition DEGs for each cluster
  # 
  # Here we plot the top 3 differentially expressed genes across conditions from each cluster.
  # In other words, in cluster 1, we have the top 3 DEGs from %s and the top 3 DEGs from %s, then the same in cluster 2, so on.
  # 
  # 
  # 
  # '
  #   
  #   cat(sprintf(plotlab, c1, c2))
  #   
  #   print(deplotlist$hm_DE)
  
  
  #   ### this is kind of bugged, it prints the plot without making the title a heading...
  #   cat('\n\n\n')
  #   
  #   plotlab <- '
  # ### Heatmap of top cross-condition DEGs for after averaging each cluster
  # 
  # Here we plot the top 3 differentially expressed genes across conditions from each cluster.
  # This heatmap is similar to the one above, but rather than showing all the cells from each cluster, we show the cluster averages.
  # In other words, in cluster 1, we have the top 3 DEGs from %s and the top 3 DEGs from %s, then the same in cluster 2, so on.
  # 
  # 
  # 
  # '
  #   
  #   cat(sprintf(plotlab, c1, c2))
  #   
  #   print(deplotlist$hm_DE_AVG)
  
  
  
  
  
  
  
  cat('\n\n\n')
  
  plotlab <- '
### Per-cluster heatmaps of all DEGs

To ensure the differential expression results are robust, it is helpful to inspect all DEGs by visualizing them in a heatmap. For each cluster, we compare the DEGs at both the single cell level, and either the pseudobulk level (if we used pseudobulk_edgeR) or the average RISC value level (if using wilcox).



'
  
  cat(sprintf(plotlab))
  
  cluster_de_heatmap_l <- deplotlist$cluster_de_heatmap_l
  
  
  for(i in 1:length(cluster_de_heatmap_l) ){
    clust = names(cluster_de_heatmap_l)[i]
    clust = str_to_title(clust)
    
    clustplots <- cluster_de_heatmap_l[[i]]
    
    
    plotlab <- '
#### %s


'
    
    cat(sprintf(plotlab, clust))
    
    
    plotlab <- '
##### Differentially Expressed Gene Heatmap for all cells in this cluster

Here, we plot all significant DEGs for all cells in this cluster from condition A vs condition B. Condition A is denoted with positive fold change.


'
    
    cat(plotlab)
    
    
    
    print(clustplots[[1]])
    
    
    cat('\n\n\n')
    
    
    if(Pseudobulk_mode == T){
      plotlab <- '
##### Differentially Expressed Gene Heatmap plotted at pseudobulk level for replicates for this cluster

Here, we plot all significant DEGs for pseudobulked replicates in this cluster from condition A vs condition B. Condition A is denoted with positive fold change.


'
    }
    
    
    if(Pseudobulk_mode == F){
      plotlab <- '
##### Differentially Expressed Gene Heatmap plotted after averaging RISC values for samples for this cluster

Here, we plot all significant DEGs after averaging the RISC-transformed values for samples in this cluster from condition A vs condition B. Condition A is denoted with positive fold change.


'
    }
    
    
    
    
    cat(plotlab)
    
    
    print(clustplots[[2]])
    
    
    
    cat('\n\n\n')
    
    
  }
  
  rm(cluster_de_heatmap_l, clustplots)
  
  
  
  
  
  
  
  
  
  pwayDElab <- "


### Gene set enrichment analysis across conditions

Pathway analysis for the cross-condition analysis is performed for overexpressed and underexpressed genes for each cluster. This is done via Gene Set Enrichment Analysis (GSEA) [(Subramanian et al 2005)](https://www.pnas.org/doi/10.1073/pnas.0506580102).

GSEA is preferred over other pathway analysis such as fisher tests or chi-square tests because it does not require making arbitrary cutoffs to the number of DEGs and takes into account how strongly differentially expressed each gene may be. For the latter, data-driven gene-specific weight is applied. We use a standard weighting method of -log10(P-value) * sign of Log Fold Change.

The pathways we choose in pathway analysis are derived from the Molecular Signatures Database (MSIGDB) where they are sorted by categories, such as Gene Ontology (GO) Biological Process, GO Molecular Function, KEGG, Reactome, etc. These are databases that annotate genes by function or molecular pathway.


"
  
  cat(pwayDElab)
  
  
  
  
  
  
  # print the pathway analysis
  
  
  pathway_analysis_main_nonull <- pathway_analysis_mainlist[lengths(pathway_analysis_mainlist) != 0]
  
  
  #loop through each category:
  # loop thru each cluster
  # get up/down pathways if there are any in each cluster
  # make some adjustments to the table to adjust for printing: shorten gene list
  # print for whole category:
  # 1. summary of whole category, up pathways 
  # 2. summary of whole category, dn pathways
  # 3. cluster by cluster, up tables, up dotplots
  # 4. cluster by cluster, dn tables, dn dotplots
  
  for(i in 1:length(pathway_analysis_main_nonull) ){
    
    #get category name
    cat <- names(pathway_analysis_main_nonull)[i]
    
    
    #get actual cluster results, and remove NAs...
    pwaycat <- pathway_analysis_main_nonull[[i]]
    
    
    # remove clusters with no pathways --> this sets them to list of lengths 0
    pwaycat = lapply(pwaycat, function(clust){clust[lengths(clust) != 0]})
    
    # remove the clusters with no pathways by removing the lists of length 0
    pwaycat <- pwaycat[lengths(pwaycat) != 0]
    
    
    ### if the category has NO PATHWAYS SIGNIFICANT in ANY cluster, just skip it
    if(length(pwaycat) == 0){
      next
    }
    
    
    
    #in each category, loop thru each cluster
    
    #loop through each cluster's results; this list contains up/down for each pathway
    # j is the cluster index
    #for(j in 1:length(pwaycat) ){
    clustlist <- lapply( c( 1:length(pwaycat) ), function(j){
      
      
      #get cluster name
      clust <- names(pwaycat)[j]
      
      
      
      #get this clusters up/down list, and remove if null
      clustcat <- pwaycat[[j]]
      clustcat <- clustcat[lengths(clustcat) != 0]
      
      if(length(clustcat)==0){
        return()
      }
      
      
      
      #get the results for this cluster
      dirreslist <- clustcat
      
      #get the plot
      dp <- dirreslist$dp
      
      #get the table
      gseares <- dirreslist$gseares
      
      
      
      
      
      # use the dotplot data to subset only significant
      gseares_fromplot <- dp$data
      
      #fix up so we can match the two
      gseares_fromplot$Description <- gseares_fromplot$pathway
      gseares_fromplot$Description <- gsub(' ', replacement = '_', gseares_fromplot$Description)
      gseares_fromplot$Description <- gsub('\n', replacement = '_', gseares_fromplot$Description)
      
      gseares <- gseares[match(gseares_fromplot$Description, gseares$pathway),]
      
      
      #modify cpres... keep only important columns...
      cpshow <- gseares
      rownames(cpshow) <- NULL
      
      cpshow <- cpshow[,c('pathway', "NES", "ES", "pval", "padj", "log2err", "size", "leadingEdge")]
      
      #keep only top 5 leading edge genes
      top5gene <- sapply(cpshow$leadingEdge, function(x){
        x <- x[x!='']
        
        if(length(x) > 5){
          x <- head(x,5)
          x[6] <- '...'
        }
        
        paste(x, collapse = '/')
      })
      
      
      cpshow$leadingEdge <- top5gene
      
      
      #instead of printing, output a list of them
      
      return(
        list(cpshow=cpshow,
             dp=dp)
      )
      
      
      ## return just the cpshow
      #return(cpshow)
      
      
      
      
    }) #close cluster lapply
    
    
    names(clustlist) <- names(pwaycat)
    
    
    
    #get the summaryplots
    # i is the category index
    summplots_conds <- summplots_cats[[i]]
    
    
    
    
    
    
    
    # print for whole category:
    # 1. summary dotplot of whole category, up pathways 
    # 2. summary dotplot of whole category, dn pathways
    # 3. cluster by cluster, up/dn table and dotplots
    
    #print category label
    catlab <- "


#### %s


"
    
    #prep cluster label, will print this for each cluster
    cat(sprintf(catlab, cat))
    
    
    
    
    
    for(condidx in 1:length(c(c1,c2)) ){
      
      cond <- c(c1,c2)[condidx]
      
      
      summplot <- summplots_conds[[condidx]]
      
      
      
      
      if( is.null(summplot) ){
        
        summlab <- "


##### Summary %s, no pathways enriched
    
This category of pathways had no signifcantly enriched pathways in %s


"
        
        cat(sprintf(summlab, cond, cond))
        
        next
        
      }
      
      
      
      summlab <- "


##### Summaryplot: %s
    
Here we plot a summary of the gene sets/pathways that are enriched in genes overexpressed in %s. If there are more than 30 significant pathways total, we plot the top 5 per cluster with the lowest adjusted P value.


"
      
      cat(sprintf(summlab, cond, cond))
      
      print(summplot)
      
      
      
      
      
    }
    
    
    
    
    
    
    clustlab <- "


##### Per-cluster pathway results
      
Here we plot the pathways that are significantly enriched in the differentially expressed genes between %s and %s for each cluster.

For each condition, we display a table of the GSEA results. NES refers to Normalized Enrichment Score, the main effect size for GSEA. Positive NES indicates the pathway is enriched in %s relative to %s, and vice-versa.

If a cluster is missing, it indicates no pathways were significantly differentially expressed.



"
    
    cat(sprintf(clustlab, c1, c2, c1, c2))
    
    
    #for each cluster, print out the dotplot and table,
    # or a print a message saying none significant
    for(clust in names(clustlist) ){
      
      
      
      
      
      clust_cond_lab <- "





###### %s


"
      
      cat(sprintf(clust_cond_lab, clust))
      
      
      
      clust_plot_tab <- clustlist[[clust]]
      
      
      
      cpshow <- clust_plot_tab$cpshow
      dp <- clust_plot_tab$dp
      
      
      
      print( knitr::kable(cpshow) )
      print(dp)
      
      
      
      
      
    } #close cluster printing loop
    
    
  } # close category by category for loop
  
  
  
} # close comparisons loop





```






# Run info

## Run time

```{r timeprint, results=T, message=T}

hourspassed <- (proc.time() - timestart)[3]/60/60
names(hourspassed) <- 'Hours'
hourspassed

```



## Memory usage

```{r memprint, results=T, message=T}

rm(list=ls())

finalmem <- gc(verbose = T, full = T)

mb <- sum(finalmem[,ncol(finalmem)])
gb <- mb / 1000
gb <- setNames(gb,'Gb used (approximately)')

gb

```




## Session info

```{r sessioninfo, results=T, message=T}
# beepr::beep()

sessionInfo()
```




